1
00:00:00,400 --> 00:00:01,739
このビデオでは、最急降下法を

2
00:00:01,739 --> 00:00:05,133
よりうまく運用するための、実践的な知識を提供する。

3
00:00:05,133 --> 00:00:06,563
このビデオの話題の中心は

4
00:00:06,563 --> 00:00:09,414
学習率アルファだ。

5
00:00:09,551 --> 00:00:11,625
具体的には、ここに最急降下法の

6
00:00:11,640 --> 00:00:13,677
更新規則があって、

7
00:00:13,677 --> 00:00:14,908
このビデオで扱う内容は、

8
00:00:14,908 --> 00:00:16,784
1つ目には、 デバッグ方法や、

9
00:00:16,784 --> 00:00:18,629
最急降下法が

10
00:00:18,629 --> 00:00:19,994
うまく実行されているのを確認するための

11
00:00:19,994 --> 00:00:22,385
方法を伝授すること。

12
00:00:22,390 --> 00:00:23,632
2つ目に、私がやっている、

13
00:00:23,632 --> 00:00:25,879
学習率アルファを選ぶ方法だ。

14
00:00:25,890 --> 00:00:27,079
私がどうやって

15
00:00:27,079 --> 00:00:29,222
選んでいるか。

16
00:00:29,222 --> 00:00:30,702
私が最急降下法がうまく行っているかを

17
00:00:30,702 --> 00:00:34,125
確認する時に良くやるのはこれだ。

18
00:00:34,125 --> 00:00:35,852
最急降下法の仕事は

19
00:00:35,852 --> 00:00:37,107
シータを見つける、

20
00:00:37,107 --> 00:00:38,710
ということだ。

21
00:00:38,710 --> 00:00:42,692
それはコスト関数Jを最小化することだ。

22
00:00:42,692 --> 00:00:44,285
私が良くやるのは

23
00:00:44,300 --> 00:00:46,121
最急降下法を走らせつつ、

24
00:00:46,121 --> 00:00:49,731
コスト関数Jを抜き出す。

25
00:00:49,750 --> 00:00:51,367
つまり、このX軸は

26
00:00:51,367 --> 00:00:52,828
繰り返し回数で、最急降下法が

27
00:00:52,850 --> 00:00:54,278
実行されるにつれて

28
00:00:54,278 --> 00:00:55,985
このようなプロットが

29
00:00:55,985 --> 00:00:59,722
得られるのを期待している。

30
00:00:59,722 --> 00:01:01,249
気をつけて欲しいのは、

31
00:01:01,249 --> 00:01:03,592
X軸は繰り返しの回数だ。

32
00:01:03,592 --> 00:01:05,098
以前も、コスト関数Jの

33
00:01:05,098 --> 00:01:07,050
プロットを見たが、

34
00:01:07,050 --> 00:01:08,931
その時のx軸、つまり横軸は

35
00:01:08,950 --> 00:01:13,122
パラメータベクトルのシータだった。今回は違う。

36
00:01:13,122 --> 00:01:15,068
具体的には、このプロットは

37
00:01:15,090 --> 00:01:17,725
最急降下法を、実際に

38
00:01:17,725 --> 00:01:20,608
100回ほど実行して、

39
00:01:20,608 --> 00:01:22,608
繰り返しを100回行った後に

40
00:01:22,620 --> 00:01:24,095
得られたシータの値だ。

41
00:01:24,110 --> 00:01:25,620
それがどんな値であれ、

42
00:01:25,620 --> 00:01:27,139
100回繰り返せば、

43
00:01:27,150 --> 00:01:29,150
とにかく何らかのシータの値が得られる。

44
00:01:29,150 --> 00:01:30,683
そしてコスト関数Jのシータを

45
00:01:30,683 --> 00:01:32,857
その100回の繰り返しによって

46
00:01:32,857 --> 00:01:34,118
得られたシータの値で

47
00:01:34,120 --> 00:01:36,272
評価する。

48
00:01:36,272 --> 00:01:37,718
この垂直方向の高さは

49
00:01:37,718 --> 00:01:39,961
Jのシータの値で、

50
00:01:39,961 --> 00:01:41,135
最急降下法を

51
00:01:41,135 --> 00:01:42,212
100回走らせた時の

52
00:01:42,220 --> 00:01:44,050
シータの値だ。

53
00:01:44,050 --> 00:01:46,515
そしてこのプロットは、

54
00:01:46,515 --> 00:01:48,253
Jのシータの値のうち、

55
00:01:48,253 --> 00:01:50,120
最急降下法を

56
00:01:50,120 --> 00:01:52,097
200回 走らせた後の

57
00:01:52,097 --> 00:01:55,172
シータの値だ。

58
00:01:55,172 --> 00:01:56,713
つまりこのプロットたちは

59
00:01:56,720 --> 00:01:58,177
最急降下法の繰り返しを行った後の

60
00:01:58,200 --> 00:02:02,025
コスト関数の値だ。

61
00:02:02,025 --> 00:02:03,335
そして、最急降下法が

62
00:02:03,350 --> 00:02:05,180
正しく機能しているなら、

63
00:02:05,190 --> 00:02:08,952
Jのシータは減少していくはずだ、

64
00:02:08,952 --> 00:02:12,219
繰り返しのたびに。

65
00:02:16,451 --> 00:02:19,248
そしてこの手のプロットの

66
00:02:19,248 --> 00:02:20,580
良い点は、

67
00:02:20,580 --> 00:02:22,545
ここに描いた図を

68
00:02:22,545 --> 00:02:24,147
見ると、

69
00:02:24,160 --> 00:02:26,015
だいたい300回くらい

70
00:02:26,030 --> 00:02:27,581
繰り返して、

71
00:02:27,581 --> 00:02:29,744
だいたい300から400の間くらい

72
00:02:29,744 --> 00:02:31,348
この区間のあたり、

73
00:02:31,348 --> 00:02:32,908
ここまで行くと、 

74
00:02:32,910 --> 00:02:35,792
Jのシータは、もうこれ以上、下がらない。

75
00:02:35,810 --> 00:02:36,930
だから400回くらい

76
00:02:36,960 --> 00:02:38,785
繰り返すと

77
00:02:38,810 --> 00:02:41,554
このカーブは平坦になってくる。

78
00:02:41,554 --> 00:02:43,334
だからこの400回まで

79
00:02:43,340 --> 00:02:44,533
来たら、

80
00:02:44,533 --> 00:02:45,847
最急降下法はだいたい

81
00:02:45,850 --> 00:02:47,868
収束している、

82
00:02:47,880 --> 00:02:50,493
コスト関数はもう下がらないから。

83
00:02:50,493 --> 00:02:51,625
つまり、この図を見ると、

84
00:02:51,625 --> 00:02:53,390
最急降下法が本当に収束したか、

85
00:02:53,420 --> 00:02:56,812
判断できる。

86
00:02:57,550 --> 00:02:58,900
ところで、最急降下法が

87
00:02:58,900 --> 00:03:00,820
収束するまでの

88
00:03:00,820 --> 00:03:02,098
繰り返しの数には

89
00:03:02,098 --> 00:03:04,251
大きな幅がある。

90
00:03:04,251 --> 00:03:06,092
ある最急降下法の適用例なら

91
00:03:06,130 --> 00:03:07,832
たった30回の繰り返しで

92
00:03:07,832 --> 00:03:10,198
収束するかもしれないし、

93
00:03:10,210 --> 00:03:12,670
別の最急降下法の適用例なら

94
00:03:12,670 --> 00:03:15,042
3000回かもしれない。

95
00:03:15,050 --> 00:03:17,996
別の学習アルゴリズムだと

96
00:03:17,996 --> 00:03:19,823
300万回ということもある。

97
00:03:19,823 --> 00:03:20,768
結局、どれだけ

98
00:03:20,768 --> 00:03:22,312
繰り返すと

99
00:03:22,312 --> 00:03:24,333
収束するかを、事前に知るのは、

100
00:03:24,360 --> 00:03:26,252
非常に難しい。

101
00:03:26,252 --> 00:03:28,935
そこで普通は、こんな風な

102
00:03:28,940 --> 00:03:32,958
繰り返しごとの、コスト関数の変化をプロットする。

103
00:03:32,960 --> 00:03:34,347
普段私は、これらのプロットを見て、

104
00:03:34,347 --> 00:03:35,610
最急降下法が収束したかを

105
00:03:35,610 --> 00:03:38,470
判断する。

106
00:03:38,590 --> 00:03:40,118
また、自動収束テストを

107
00:03:40,130 --> 00:03:42,748
作ることも可能だ、

108
00:03:42,748 --> 00:03:44,306
つまり、最急降下法が

109
00:03:44,306 --> 00:03:46,593
収束したかを

110
00:03:46,593 --> 00:03:48,615
判定するアルゴリズム、

111
00:03:48,620 --> 00:03:50,268
これがたぶん良くやられている

112
00:03:50,268 --> 00:03:52,505
自動収束テストの例で、

113
00:03:52,540 --> 00:03:54,981
こんな感じで、収束したかテストする。

114
00:03:54,981 --> 00:03:57,009
つまりコスト関数Jのシータが

115
00:03:57,020 --> 00:03:58,396
一回の繰り返しで

116
00:03:58,396 --> 00:04:01,435
ある小さな値イプシロンより

117
00:04:01,435 --> 00:04:02,412
これは10のマイナス3乗などだが、

118
00:04:02,412 --> 00:04:05,272
それよりも減少が小さくなったら、収束したとする。

119
00:04:05,272 --> 00:04:07,065
しかし、やってみると、

120
00:04:07,070 --> 00:04:10,740
この閾値を決めるのは、普通、非常に難しい。

121
00:04:10,740 --> 00:04:12,049
だから、最急降下法が

122
00:04:12,049 --> 00:04:14,058
実際に収束しているかを確認するには

123
00:04:14,090 --> 00:04:15,361
私は実際に

124
00:04:15,361 --> 00:04:17,074
この左側のプロットを見る方が

125
00:04:17,074 --> 00:04:18,299
多い、

126
00:04:18,310 --> 00:04:21,778
自動収束テストに頼るよりも。

127
00:04:21,778 --> 00:04:22,778
また、この種の図を見ることで

128
00:04:22,780 --> 00:04:24,340
最急降下法が正しく機能しているか、

129
00:04:24,340 --> 00:04:25,812
さらに高度な情報を

130
00:04:25,820 --> 00:04:28,659
与えてくれることもある。

131
00:04:28,690 --> 00:04:30,185
具体的に言うと、

132
00:04:30,200 --> 00:04:31,641
Jのシータを繰り返し回数の関数として

133
00:04:31,650 --> 00:04:34,850
プロットして、

134
00:04:34,850 --> 00:04:35,864
もしこんな図になったら、

135
00:04:35,864 --> 00:04:37,105
つまり、Jのシータが実際には

136
00:04:37,120 --> 00:04:39,136
増加していたら、

137
00:04:39,136 --> 00:04:42,898
それは最急降下法が正しく機能していない、明らかなサインだ。

138
00:04:42,898 --> 00:04:44,552
そしてこんな図になったら、だいたいは、

139
00:04:44,552 --> 00:04:48,253
より小さな学習率アルファを使え、ということだ。

140
00:04:48,270 --> 00:04:49,697
もしJのシータか実際に増加していたら、

141
00:04:49,697 --> 00:04:51,564
その一番よくある原因は

142
00:04:51,580 --> 00:04:53,199
もし最小化しようとしている

143
00:04:53,199 --> 00:04:54,904
目的の関数が

144
00:04:54,904 --> 00:04:59,346
このような見た目だったとして、

145
00:04:59,346 --> 00:05:00,518
学習率が大きすぎるときは、

146
00:05:00,518 --> 00:05:01,614
仮にここから始めたとすると、

147
00:05:01,614 --> 00:05:03,202
最急降下法は

148
00:05:03,202 --> 00:05:05,516
最小を行き過ぎて、

149
00:05:05,516 --> 00:05:07,145
ここまで行ってしまう。そして大きすぎると、

150
00:05:07,145 --> 00:05:08,473
さらに行き過ぎてしまい、

151
00:05:08,500 --> 00:05:10,493
ここに行く。このように続いてしまう。

152
00:05:10,500 --> 00:05:12,279
本当は

153
00:05:12,279 --> 00:05:13,810
ここから始めて

154
00:05:13,810 --> 00:05:17,991
少しずつ、この丘を降りたかった。

155
00:05:17,991 --> 00:05:19,465
しかし学習率が大きすぎたため、

156
00:05:19,465 --> 00:05:21,252
最急降下法が

157
00:05:21,252 --> 00:05:22,749
最小を通り過ぎることを

158
00:05:22,760 --> 00:05:24,454
続けてしまい、

159
00:05:24,454 --> 00:05:26,147
結果としては

160
00:05:26,160 --> 00:05:27,170
どんどん悪くなってしまう、

161
00:05:27,210 --> 00:05:28,720
代わりに、どんどんコスト関数Jのシータが

162
00:05:28,780 --> 00:05:30,744
高くなっていく。

163
00:05:30,744 --> 00:05:31,751
だから結局、プロットは

164
00:05:31,751 --> 00:05:33,263
このような感じとなる。

165
00:05:33,263 --> 00:05:34,248
もしこういうプロットを見たら、

166
00:05:34,248 --> 00:05:36,106
だから、普通の修正は

167
00:05:36,106 --> 00:05:38,182
アルファにもっと小さい値を設定する。

168
00:05:38,182 --> 00:05:39,640
もちろん、コードに

169
00:05:39,790 --> 00:05:41,872
バグがないことも確認する。

170
00:05:41,872 --> 00:05:43,268
たが普通は、アルファの値が

171
00:05:43,268 --> 00:05:44,709
大きすぎるのが

172
00:05:44,709 --> 00:05:48,105
もっともありがちな問題点だ。

173
00:05:49,050 --> 00:05:50,595
同様に、まれに、

174
00:05:50,595 --> 00:05:52,115
Jのシータが

175
00:05:52,120 --> 00:05:53,188
こんな感じなのを見ることがある。

176
00:05:53,188 --> 00:05:54,158
しばらく下がった後に

177
00:05:54,160 --> 00:05:56,325
その後上がって、またしばらく下がって、またその後上がる。

178
00:05:56,330 --> 00:05:57,366
しばらく下がって

179
00:05:57,366 --> 00:05:58,910
また上がる。などなど。

180
00:05:58,930 --> 00:06:00,150
そしてこれの修正も、

181
00:06:00,150 --> 00:06:04,052
より小さなアルファを使う。

182
00:06:04,090 --> 00:06:05,129
ここでは証明はしないが、

183
00:06:05,129 --> 00:06:07,128
ある前提の下では、コスト関数は、

184
00:06:07,128 --> 00:06:10,806
その前提は線形回帰ではいつも真だが、

185
00:06:10,830 --> 00:06:12,608
数学者によると、

186
00:06:12,608 --> 00:06:13,913
学習率アルファが

187
00:06:13,913 --> 00:06:15,885
十分に小さければ、

188
00:06:15,885 --> 00:06:19,025
Jのシータは、繰り返すごとに、毎回確実に減少する。

189
00:06:19,030 --> 00:06:21,342
だから、もしそうでなければ、

190
00:06:21,342 --> 00:06:22,338
たぶん大きすぎるので、

191
00:06:22,338 --> 00:06:23,992
より小さな値を使うべき…しかし、

192
00:06:23,992 --> 00:06:24,867
もちろん、小さすぎる値にも

193
00:06:24,890 --> 00:06:25,788
気を付ける。

194
00:06:25,788 --> 00:06:27,068
何故なら、もし万が一、

195
00:06:27,070 --> 00:06:28,095
小さすぎる値を使うと

196
00:06:28,095 --> 00:06:31,543
最急降下法は収束までが遅くなってしまう。

197
00:06:31,543 --> 00:06:32,812
もしアルファを小さくし過ぎたとして、

198
00:06:32,812 --> 00:06:34,804
ここから始めることに

199
00:06:34,804 --> 00:06:36,945
なったとすると、

200
00:06:36,960 --> 00:06:38,248
一歩一歩が小さく、

201
00:06:38,248 --> 00:06:40,408
赤ちゃんのハイハイのようにしか進まなくなる。

202
00:06:40,408 --> 00:06:41,438
いいかな？

203
00:06:41,438 --> 00:06:42,974
それは、最小になるまで、

204
00:06:42,980 --> 00:06:47,064
非常に多くの繰り返しが必要ということだ。

205
00:06:47,090 --> 00:06:48,118
つまり、アルファが小さすぎると

206
00:06:48,118 --> 00:06:49,500
最急降下法は非常にゆっくりとしか進まず、

207
00:06:49,570 --> 00:06:52,989
収束までが遅くなる。

208
00:06:53,005 --> 00:06:55,377
まとめると、

209
00:06:55,377 --> 00:06:57,301
学習率が小さすぎると

210
00:06:57,301 --> 00:06:59,672
収束が遅い問題に遭遇する。

211
00:06:59,672 --> 00:07:01,161
そして学習率が大きすぎると

212
00:07:01,161 --> 00:07:02,494
Jのシータは、繰り返しで

213
00:07:02,494 --> 00:07:04,378
減少せず、

214
00:07:04,378 --> 00:07:06,023
収束しないかもしれない。

215
00:07:06,023 --> 00:07:08,579
学習率が大きすぎて

216
00:07:08,579 --> 00:07:10,957
収束までが遅い、という場合もまた

217
00:07:10,990 --> 00:07:14,710
ありえる。

218
00:07:14,800 --> 00:07:16,312
しかしもっと普通に遭遇する問題は

219
00:07:16,312 --> 00:07:17,380
Jのシータは、繰り返しで

220
00:07:17,440 --> 00:07:20,532
減少しないかもしれない、ということだ。

221
00:07:20,540 --> 00:07:22,223
そして、これらを全てデバッグするために、

222
00:07:22,223 --> 00:07:24,539
Jのシータを、繰り返しの回数の関数として

223
00:07:24,539 --> 00:07:26,053
プロットすると、

224
00:07:26,070 --> 00:07:29,315
起こっていることを知る助けになる。

225
00:07:29,315 --> 00:07:31,258
より具体的には、

226
00:07:31,258 --> 00:07:32,525
実際に、最急降下法を行う時に

227
00:07:32,525 --> 00:07:34,997
私がやるのは、ある範囲の値を試す、という方法だ。

228
00:07:35,000 --> 00:07:36,555
つまり最急降下法を

229
00:07:36,580 --> 00:07:37,988
ある範囲のアルファの値、例えば0.001, 0.01,..という値で

230
00:07:37,988 --> 00:07:39,902
走らせてみる。

231
00:07:39,902 --> 00:07:41,471
つまりこれらは

232
00:07:41,471 --> 00:07:43,275
10倍ずつずれた値。

233
00:07:43,280 --> 00:07:44,449
これらの異なるアルファに対し、それぞれ

234
00:07:44,449 --> 00:07:45,769
Jのシータを、繰り返し回数の関数として

235
00:07:45,769 --> 00:07:47,015
プロットして、

236
00:07:47,030 --> 00:07:49,202
そこから、

237
00:07:49,202 --> 00:07:51,094
Jのシータが速く減少しているものを

238
00:07:51,094 --> 00:07:54,805
選ぶのだ。

239
00:07:54,805 --> 00:07:58,067
実は、私が実際にやる手順は、こうではない。

240
00:07:58,067 --> 00:07:59,305
これは10倍ずつ

241
00:07:59,305 --> 00:08:01,780
増えていくが、

242
00:08:01,869 --> 00:08:03,860
私が実際にやるのは、

243
00:08:03,870 --> 00:08:07,164
この範囲の間の値を試していく、

244
00:08:07,164 --> 00:08:09,770
こんな感じ、

245
00:08:09,816 --> 00:08:11,365
つまり、0.001を試したあと

246
00:08:11,365 --> 00:08:13,598
定数倍で3倍して

247
00:08:13,598 --> 00:08:15,182
0.003を得て、

248
00:08:15,182 --> 00:08:17,356
次のステップでもさらに

249
00:08:17,356 --> 00:08:20,187
だいたい3倍で

250
00:08:20,187 --> 00:08:22,145
0.003から0.01として、

251
00:08:22,145 --> 00:08:24,605
だいたい、

252
00:08:24,605 --> 00:08:27,343
最急降下法で

253
00:08:27,343 --> 00:08:28,580
各値を前の値の3倍して

254
00:08:28,580 --> 00:08:30,592
実行していく。

255
00:08:30,592 --> 00:08:32,256
要するに、私がやっているのは

256
00:08:32,256 --> 00:08:33,495
確実に小さすぎる値を、

257
00:08:33,495 --> 00:08:34,725
一つ見つけて、

258
00:08:34,725 --> 00:08:35,757
確実に大きすぎる値も

259
00:08:35,757 --> 00:08:37,137
一つ見つけて、

260
00:08:37,137 --> 00:08:38,394
そしてそれを使うか、または

261
00:08:38,394 --> 00:08:40,560
それよりは少しだけ

262
00:08:40,560 --> 00:08:42,279
小さい値を選んで、

263
00:08:42,279 --> 00:08:43,764
この範囲に

264
00:08:43,764 --> 00:08:46,488
使う。

265
00:08:46,488 --> 00:08:48,178
そうすれば、だいたいは

266
00:08:48,178 --> 00:08:49,592
その問題での、妥当な学習率を

267
00:08:49,592 --> 00:08:51,968
見つけられる。

268
00:08:51,968 --> 00:08:53,203
そしてあなたもきっと、

269
00:08:53,203 --> 00:08:54,345
このやり方を使えば

270
00:08:54,345 --> 00:08:55,906
最急降下法の実装の際には

271
00:08:55,906 --> 00:08:57,340
良い学習率が

272
00:08:57,340 --> 00:08:58,563
選べるだろう。
