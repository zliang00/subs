1
00:00:00,220 --> 00:00:01,128
Octave のデータ読み込み方法や、

2
00:00:01,128 --> 00:00:03,062
保存、行列へのデータ代入方法などを、

3
00:00:03,062 --> 00:00:04,743
理解できたところで、

4
00:00:04,743 --> 00:00:06,301
このビデオでは、

5
00:00:06,301 --> 00:00:08,252
データに対する演算処理を

6
00:00:08,252 --> 00:00:10,343
お見せする。

7
00:00:10,343 --> 00:00:12,296
後に、このような演算処理を使って

8
00:00:12,320 --> 00:00:16,860
学習アルゴリズムを実装していく。

9
00:00:16,860 --> 00:00:19,360
では、始めよう。

10
00:00:19,610 --> 00:00:21,031
これが私の Octave ウィンドウだ。

11
00:00:21,031 --> 00:00:22,737
では、早速、いくつか

12
00:00:22,737 --> 00:00:24,939
例題に使う変数を

13
00:00:24,940 --> 00:00:26,679
初期化する。

14
00:00:26,679 --> 00:00:29,185
A を 3 x 2 の行列に、

15
00:00:29,820 --> 00:00:31,495
そして B を

16
00:00:31,510 --> 00:00:33,319
3 x 2 の行列に設定し、

17
00:00:33,330 --> 00:00:35,106
さらに

18
00:00:35,120 --> 00:00:38,419
C を 2 x 2 の行列に設定する。

19
00:00:39,150 --> 00:00:41,948
さて、二つの行列の乗算をしたいとする。

20
00:00:41,960 --> 00:00:44,121
例えば、A 掛ける C を計算する。

21
00:00:44,121 --> 00:00:45,713
これは単に A  Cと入力するだけだ。

22
00:00:45,740 --> 00:00:48,848
これは、3 x 2 行列掛ける 2 x 2 行列だ。

23
00:00:48,860 --> 00:00:52,135
すると、この 3 x 2 の行列が得られる。

24
00:00:52,160 --> 00:00:53,736
また、要素単位での

25
00:00:53,740 --> 00:00:56,472
演算も可能で、

26
00:00:56,500 --> 00:00:57,615
A . B とすると、実行されるのは

27
00:00:57,615 --> 00:00:59,138
A の各要素を

28
00:00:59,138 --> 00:01:00,584
対応する B の各要素に

29
00:01:00,590 --> 00:01:02,558
掛け合わせる。

30
00:01:02,560 --> 00:01:06,390
だから、これが A、これが B、そしてこれが A.<i>B</i>

31
00:01:06,700 --> 00:01:09,412
だから、例えば、最初の要素は

32
00:01:09,420 --> 00:01:10,940
1 x 11 なので 11、

33
00:01:10,950 --> 00:01:14,045
二番目の要素は

34
00:01:14,045 --> 00:01:16,752
2 x 12 で 24、になる。

35
00:01:16,760 --> 00:01:18,196
このように、要素単位での

36
00:01:18,196 --> 00:01:19,673
二つの行列の乗算だ。

37
00:01:19,673 --> 00:01:21,500
Octaveでは、一般的に、

38
00:01:21,520 --> 00:01:23,359
ピリオドは、

39
00:01:23,380 --> 00:01:25,132
通常、要素単位での

40
00:01:25,132 --> 00:01:27,435
操作を示す記号として使われる。

41
00:01:27,435 --> 00:01:28,882
だから、ここにある 行列 A に対し、

42
00:01:28,882 --> 00:01:31,735
A .^2 とすると、

43
00:01:31,735 --> 00:01:33,001
これは、

44
00:01:33,010 --> 00:01:35,671
要素単位での

45
00:01:35,690 --> 00:01:37,411
A の二乗になるので、1の二乗は1、

46
00:01:37,411 --> 00:01:40,813
2 の二乗は 4、となる。

47
00:01:40,870 --> 00:01:42,215
では、V をベクトルに設定する。

48
00:01:42,260 --> 00:01:46,085
V を 1、2、3 の列ベクトルにする。

49
00:01:46,180 --> 00:01:47,848
また、

50
00:01:47,860 --> 00:01:49,675
1./V として、

51
00:01:49,675 --> 00:01:51,533
V の要素単位の逆行列を求めると、

52
00:01:51,533 --> 00:01:53,176
これが戻すのは、

53
00:01:53,210 --> 00:01:55,600
1/1、1/2、そして 1/3 だ。

54
00:01:55,600 --> 00:01:56,898
これは行列でも使えるので、

55
00:01:56,898 --> 00:01:58,436
1 ./ A とすると、

56
00:01:58,470 --> 00:02:00,464
これは 要素単位の A の逆行列だ。

57
00:02:00,520 --> 00:02:03,342
もう一度繰り返すと、

58
00:02:03,342 --> 00:02:04,813
ピリオドは、

59
00:02:04,830 --> 00:02:08,193
要素単位の処理であることを示す。

60
00:02:08,193 --> 00:02:09,663
また、こんなこともできる。

61
00:02:09,663 --> 00:02:11,591
log V これは、要素単位での

62
00:02:11,600 --> 00:02:14,257
V の対数で、

63
00:02:14,257 --> 00:02:15,418
exp(V) は、

64
00:02:15,420 --> 00:02:17,394
e を底にとった

65
00:02:17,394 --> 00:02:20,288
これらの要素の冪乗で、

66
00:02:20,330 --> 00:02:21,432
これが e、

67
00:02:21,432 --> 00:02:23,105
これが e squared EQ、

68
00:02:23,105 --> 00:02:26,010
これは V だ。

69
00:02:26,120 --> 00:02:28,187
また、abs(V) とすると、

70
00:02:28,230 --> 00:02:30,172
これは要素単位での

71
00:02:30,172 --> 00:02:32,056
V の絶対値だ。

72
00:02:32,056 --> 00:02:34,418
ここでは、V はすべて正の値だったが、

73
00:02:34,430 --> 00:02:36,503
abs、マイナス 1 からマイナス 3、

74
00:02:36,503 --> 00:02:38,543
要素単位の絶対値として

75
00:02:38,543 --> 00:02:40,428
戻されるのは、

76
00:02:40,430 --> 00:02:43,929
これらの、負でない数値だ。

77
00:02:43,929 --> 00:02:45,465
-V は、負の V を返す。

78
00:02:45,465 --> 00:02:46,715
これは、-1<i>V と同じ</i>だが、

79
00:02:46,730 --> 00:02:49,085
通常は、

80
00:02:49,085 --> 00:02:50,653
-V とだけ表記し、-1<i>V</i>

81
00:02:50,653 --> 00:02:55,340
とはしない。他に何があるかな。

82
00:02:55,990 --> 00:02:57,185
別のいいコツがあった。

83
00:02:57,185 --> 00:02:58,343
さて、見てみよう。

84
00:02:58,343 --> 00:03:01,424
V に対して、各要素を 1 増やしたい。

85
00:03:01,424 --> 00:03:02,520
一つのやり方は

86
00:03:02,520 --> 00:03:05,407
3 x 1 ベクトルを

87
00:03:05,420 --> 00:03:09,010
作成して

88
00:03:09,660 --> 00:03:12,666
これはすべて 1 で、そしてこれを V に足す。

89
00:03:12,666 --> 00:03:15,373
これを実行すると 1 2 3 だった V が、2 3 4 と1ずつ増える。

90
00:03:15,373 --> 00:03:16,804
このやり方は

91
00:03:16,804 --> 00:03:21,439
V の長さが 3 だから

92
00:03:21,890 --> 00:03:23,790
ones、length(V)、

93
00:03:23,790 --> 00:03:25,792
1、これはones

94
00:03:25,820 --> 00:03:27,055
(3, 1) だ。

95
00:03:27,055 --> 00:03:29,525
だから、ones(3, 1) 、確かになった。

96
00:03:29,580 --> 00:03:31,150
そして次は

97
00:03:31,230 --> 00:03:33,198
V + ones

98
00:03:33,198 --> 00:03:35,139
(3, 1)、つまり

99
00:03:35,150 --> 00:03:36,605
このすべて 1 のベクトルを

100
00:03:36,610 --> 00:03:38,112
 V に足したわけだ。

101
00:03:38,112 --> 00:03:40,340
これで、 V が 1 インクリメントされる。

102
00:03:40,340 --> 00:03:41,984
もう一つ、さらに簡単な方法は、

103
00:03:41,984 --> 00:03:44,472
V + 1 と入力すること。

104
00:03:44,472 --> 00:03:45,600
だから、これが V で

105
00:03:45,650 --> 00:03:46,989
V + 1 の意味は、

106
00:03:47,000 --> 00:03:49,257
1 を要素単位で

107
00:03:49,280 --> 00:03:52,458
V の各要素に加えなさいということ。

108
00:03:52,458 --> 00:03:55,422
さらに演算について話す。

109
00:03:55,450 --> 00:03:58,848
ここに 行列 A がある。この A の転置行列を求めたい場合、

110
00:03:58,848 --> 00:04:00,841
 A' と入力する。

111
00:04:00,900 --> 00:04:02,653
これはアポストロフィー記号、

112
00:04:02,660 --> 00:04:03,770
左の引用符だ。

113
00:04:03,770 --> 00:04:05,355
キーボードには

114
00:04:05,355 --> 00:04:06,975
左の引用符と

115
00:04:06,975 --> 00:04:08,106
右の引用符があると思う。

116
00:04:08,106 --> 00:04:09,901
だから、これは、

117
00:04:09,950 --> 00:04:12,304
行順的な引用符で、

118
00:04:12,304 --> 00:04:14,765
単に A' と入力すると

119
00:04:14,765 --> 00:04:16,172
これは、

120
00:04:16,172 --> 00:04:17,228
行列 A の転置行列が

121
00:04:17,228 --> 00:04:18,919
得られる。もちろん、

122
00:04:18,919 --> 00:04:20,405
転置の、再転置を

123
00:04:20,405 --> 00:04:21,650
行えば、

124
00:04:21,650 --> 00:04:26,509
元の 行列 A に戻る。さらに便利な関数について。

125
00:04:26,540 --> 00:04:28,646
例えば、小文字の a を

126
00:04:28,646 --> 00:04:30,546
1、15、2、0.5 とする。

127
00:04:30,546 --> 00:04:34,266
これは 1 x 4 行列だ。

128
00:04:34,266 --> 00:04:36,239
そこで、 val = max(a) とすると

129
00:04:36,239 --> 00:04:37,833
これが戻すのは

130
00:04:37,833 --> 00:04:39,328
A の最大値だ。

131
00:04:39,328 --> 00:04:41,481
この場合は 15 だ。そして

132
00:04:41,500 --> 00:04:44,465
val、ind、max(A)

133
00:04:44,490 --> 00:04:47,115
とすることもでき、これが返すのは

134
00:04:47,120 --> 00:04:49,634
val と ind、それは

135
00:04:49,634 --> 00:04:51,289
A の最大値、

136
00:04:51,289 --> 00:04:52,943
つまり 15 と、さらにその位置だ。

137
00:04:52,943 --> 00:04:56,028
A の 二番目の要素が 15 だったので、

138
00:04:56,028 --> 00:04:58,766
ind は、それに対応する位置だ。

139
00:04:58,766 --> 00:05:00,148
注意点としては、

140
00:05:00,148 --> 00:05:03,155
もし A が行列の場合、 

141
00:05:03,180 --> 00:05:04,746
max(A) が返すのは、

142
00:05:04,780 --> 00:05:07,848
列単位での最大値だ。

143
00:05:07,860 --> 00:05:11,525
これについてはこの後で触れる。

144
00:05:11,570 --> 00:05:13,305
さて、この小文字の変数 a の例を

145
00:05:13,305 --> 00:05:17,008
引き続き使う。もし、a < 3 とすると、

146
00:05:17,040 --> 00:05:19,548
これは、要素単位での演算、

147
00:05:19,590 --> 00:05:21,063
要素単位での比較だ。

148
00:05:21,063 --> 00:05:22,624
だから、a の最初の要素は

149
00:05:22,624 --> 00:05:24,855
3 以下なので 1 となり、

150
00:05:24,855 --> 00:05:26,315
a の二番目の要素は

151
00:05:26,315 --> 00:05:27,435
3 以下ではないので、その値は 0、

152
00:05:27,435 --> 00:05:29,948
なぜなら偽だからだ。

153
00:05:29,950 --> 00:05:31,258
a の三番目と四番目の要素は

154
00:05:31,300 --> 00:05:32,866
レッスン、いえ、

155
00:05:32,870 --> 00:05:35,667
3 以下なので、三番目と四番目の要素は3 以下なので

156
00:05:35,667 --> 00:05:36,826
これは 1、1、だから

157
00:05:36,826 --> 00:05:38,441
これは要素単位で

158
00:05:38,460 --> 00:05:40,241
四つのすべての要素を

159
00:05:40,280 --> 00:05:42,504
比較する。小文字の変数 a < 3 は、

160
00:05:42,520 --> 00:05:44,008
要素が 3 以下かを検査し、

161
00:05:44,020 --> 00:05:47,382
真あるいは偽を返す。

162
00:05:47,400 --> 00:05:48,843
さて、

163
00:05:48,880 --> 00:05:50,708
find(a < 3) とすると、

164
00:05:50,710 --> 00:05:52,149
a の

165
00:05:52,190 --> 00:05:53,805
どの要素が、

166
00:05:53,860 --> 00:05:55,202
変数 A が、3 以下かを返す。

167
00:05:55,202 --> 00:05:56,964
よってこの場合は、一番目、三番目

168
00:05:56,964 --> 00:06:00,244
そして四番目の要素が、 3 以下だ。

169
00:06:00,244 --> 00:06:01,465
次の例として、

170
00:06:01,465 --> 00:06:03,335
A を =magic(3) に

171
00:06:03,340 --> 00:06:05,765
設定する。

172
00:06:05,765 --> 00:06:07,409
magic 関数が

173
00:06:09,390 --> 00:06:12,581
戻すのは、

174
00:06:12,581 --> 00:06:15,362
魔方陣とよばれる行列だ。

175
00:06:15,362 --> 00:06:17,722
こうした行列は、

176
00:06:17,740 --> 00:06:20,012
特有の数学的な特性があり、

177
00:06:20,030 --> 00:06:21,590
すべての行と列と対角線上の

178
00:06:21,590 --> 00:06:23,730
数字の合計が、同じ値になる。

179
00:06:23,730 --> 00:06:25,535
だから、

180
00:06:25,580 --> 00:06:27,378
機械学習では、

181
00:06:27,378 --> 00:06:28,385
用途は限定されているが、

182
00:06:28,385 --> 00:06:29,688
わたしは、単に

183
00:06:29,688 --> 00:06:31,720
3 x 3 の 行列を作成するのに

184
00:06:31,720 --> 00:06:33,058
便利に使っている。

185
00:06:33,058 --> 00:06:36,206
この画面上の魔方陣の

186
00:06:36,220 --> 00:06:37,228
特徴は、

187
00:06:37,228 --> 00:06:39,500
それぞれの行、それぞれの列、そして

188
00:06:39,510 --> 00:06:41,055
対角線の合計が

189
00:06:41,055 --> 00:06:44,487
同じ数になる。そういう数学的な概念だ。

190
00:06:44,510 --> 00:06:45,789
私が、この

191
00:06:45,800 --> 00:06:47,110
magic 関数を使うのは、

192
00:06:47,110 --> 00:06:48,118
デモを行うときや、

193
00:06:48,140 --> 00:06:49,571
 Octave を教えている時だけで

194
00:06:49,580 --> 00:06:51,103
実際には、実用的な機械学習の用途では

195
00:06:51,103 --> 00:06:53,846
使わない。

196
00:06:53,860 --> 00:06:59,356
しかし、[r, c] = find(A >= 7)  と入力すると、

197
00:06:59,390 --> 00:07:02,657
これは、A の中の

198
00:07:02,657 --> 00:07:03,797
7 以上の全要素を

199
00:07:03,797 --> 00:07:05,246
見つける。そして

200
00:07:05,246 --> 00:07:07,044
r と c は 行と列の略だ。

201
00:07:07,100 --> 00:07:09,392
だから、 1 、1 の要素は 7 以上

202
00:07:09,400 --> 00:07:10,973
3、2 の要素は 7 以上、

203
00:07:10,980 --> 00:07:13,178
そして 2 、3 の要素は 7 以上だ。

204
00:07:13,200 --> 00:07:14,788
だから、2、3 の要素は、

205
00:07:14,800 --> 00:07:18,803
例えば、A(2, 3)は 7、

206
00:07:18,850 --> 00:07:21,102
これはこの要素だ、

207
00:07:21,120 --> 00:07:24,248
そしてそれは、確かに 7 以上だ。

208
00:07:24,248 --> 00:07:26,005
ちなみに、実際には、私は自分でも

209
00:07:26,030 --> 00:07:27,613
こうした find 関数が

210
00:07:27,613 --> 00:07:28,944
どんな働きをするのか、

211
00:07:28,960 --> 00:07:30,323
覚えていないので、

212
00:07:30,323 --> 00:07:31,399
find 関数を使うたびに

213
00:07:31,399 --> 00:07:33,042
時々、それが正確には何をするのか忘れていて、

214
00:07:33,070 --> 00:07:34,791
そういう場合は、

215
00:07:34,791 --> 00:07:37,952
help find と入力してドキュメントを見る。

216
00:07:37,970 --> 00:07:40,042
そして、あと二つだけお見せする。

217
00:07:40,042 --> 00:07:41,549
一つ目は sum 関数。

218
00:07:41,549 --> 00:07:43,452
ここに a がある。

219
00:07:43,452 --> 00:07:44,755
sum(a) と入力すると

220
00:07:44,800 --> 00:07:46,500
a の全要素が加算される。

221
00:07:46,510 --> 00:07:47,660
もし、これらの掛け算をしたい場合は

222
00:07:47,660 --> 00:07:49,404
prod(a) と入力する。

223
00:07:49,410 --> 00:07:50,795
prod は、product (乗) の略だ。

224
00:07:50,800 --> 00:07:53,022
そして、これはこれらの四つの

225
00:07:53,022 --> 00:07:55,773
要素の掛け算の結果を戻す。

226
00:07:56,040 --> 00:07:58,215
floor(a) は切捨てで、

227
00:07:58,215 --> 00:07:59,465
これらの A の要素では、

228
00:07:59,470 --> 00:08:01,766
0.5 は 0 に切り捨てられる。

229
00:08:01,766 --> 00:08:03,352
そして ceil(a) つまり 天井関数 a とすると、

230
00:08:03,380 --> 00:08:04,815
切り上げになるので

231
00:08:04,815 --> 00:08:06,212
0.5 は、直近の整数に切り上げられ、

232
00:08:06,220 --> 00:08:10,735
0.5 は 1 になる。

233
00:08:10,735 --> 00:08:12,143
また、

234
00:08:12,143 --> 00:08:13,322
そうだな

235
00:08:13,322 --> 00:08:14,418
rand(3) として

236
00:08:14,418 --> 00:08:16,643
3 x 3 の行列を作成する。

237
00:08:16,680 --> 00:08:20,444
もし max(rand(3), rand(3)) とすると、

238
00:08:20,460 --> 00:08:21,848
これが実行するのは、

239
00:08:21,848 --> 00:08:24,963
二つの乱数の 3 x 3 行列から、

240
00:08:24,963 --> 00:08:26,897
要素単位で最大値を取る。

241
00:08:26,900 --> 00:08:28,017
だからこの通り、

242
00:08:28,017 --> 00:08:29,063
これらのすべての数字は

243
00:08:29,063 --> 00:08:30,948
やや大き目になっているが、

244
00:08:30,948 --> 00:08:32,581
これらはどれも、実際には

245
00:08:32,581 --> 00:08:35,093
二つの乱数から作成された

246
00:08:35,110 --> 00:08:38,269
行列の要素単位の最大値だからだ。

247
00:08:38,269 --> 00:08:40,316
これは、魔方数、

248
00:08:40,316 --> 00:08:43,258
これは 魔方陣、3 x 3 の A だ。

249
00:08:43,258 --> 00:08:47,704
例えば、max(A) として、こうすると、

250
00:08:47,730 --> 00:08:49,955
左、右、角括弧、コンマ、1

251
00:08:49,955 --> 00:08:51,344
これが戻すのは、

252
00:08:51,360 --> 00:08:53,584
列単位での最大値だ。

253
00:08:53,600 --> 00:08:54,892
最初の列の最大値は 8、

254
00:08:54,910 --> 00:08:56,517
二番目の列の

255
00:08:56,517 --> 00:08:58,335
最大は 9

256
00:08:58,335 --> 00:09:00,695
三列目の最大値は 7 だ。

257
00:09:00,695 --> 00:09:02,064
この 1 の意味は、

258
00:09:02,100 --> 00:09:03,665
A の一次元目をずっと見ていって、

259
00:09:03,700 --> 00:09:05,860
最大値を取りなさい、ということだ。これと比較して

260
00:09:05,940 --> 00:09:07,874
max(A、この変な表記、

261
00:09:07,910 --> 00:09:10,033
そして 2) と入力すると、

262
00:09:10,033 --> 00:09:12,433
これは、行単位での最大値を返す。

263
00:09:12,460 --> 00:09:13,449
だから、最初の行の

264
00:09:13,449 --> 00:09:14,525
最大値は 8、

265
00:09:14,560 --> 00:09:16,561
二番目の行の最大値は 7、

266
00:09:16,580 --> 00:09:18,105
三行目の最大値は 9 だ。

267
00:09:18,105 --> 00:09:21,605
こうして最大値を

268
00:09:21,605 --> 00:09:24,771
行単位あるいは列単位で得ることができる。

269
00:09:24,780 --> 00:09:26,988
そして

270
00:09:26,988 --> 00:09:29,019
これは、デフォルトでは列単位での

271
00:09:29,020 --> 00:09:30,091
要素の最大値が戻るので

272
00:09:30,091 --> 00:09:31,628
行列 A 全体での

273
00:09:31,630 --> 00:09:33,395
最大値の要素を

274
00:09:33,395 --> 00:09:35,040
求めたい場合は、

275
00:09:35,040 --> 00:09:36,985
max(max(a)) とすることが可能だ。

276
00:09:36,985 --> 00:09:39,558
この場合は 9 だ。

277
00:09:39,558 --> 00:09:40,640
あるいは、A を

278
00:09:40,670 --> 00:09:42,507
ベクトルにして、

279
00:09:42,507 --> 00:09:44,739
max(A(:)) とすると

280
00:09:44,750 --> 00:09:46,912
これはベクトルとして扱われ、

281
00:09:46,912 --> 00:09:51,539
そのベクトルの最大値が戻される。

282
00:09:51,572 --> 00:09:54,288
最後に、A を

283
00:09:54,288 --> 00:09:56,234
9 x 9 の魔方陣にする。

284
00:09:56,234 --> 00:09:57,853
ご存知の通り、魔方陣は、

285
00:09:57,853 --> 00:09:59,969
すべての列とすべての行の

286
00:09:59,969 --> 00:10:03,535
合計が同じになっている。対角線もだ。

287
00:10:03,535 --> 00:10:06,209
だから、ここに 9 x 9 の魔方陣がある。

288
00:10:06,240 --> 00:10:07,715
では、sum(A, 1) とする。

289
00:10:07,715 --> 00:10:10,169
すると、これは列単位での合計を戻す。

290
00:10:10,190 --> 00:10:11,104
そこで、 A のぞれぞれの列の

291
00:10:11,104 --> 00:10:12,194
の合計を取ると

292
00:10:12,194 --> 00:10:13,698
このように、

293
00:10:13,700 --> 00:10:15,365
これによって確かに

294
00:10:15,365 --> 00:10:16,935
9 x 9 の魔方陣で、

295
00:10:16,935 --> 00:10:20,124
全列の合計が同じ 369 になるか、確認できる。

296
00:10:20,124 --> 00:10:22,020
では、行単位の合計もやってみよう。

297
00:10:22,020 --> 00:10:24,643
sum(A, 2) とすると

298
00:10:24,643 --> 00:10:27,967
その合計は

299
00:10:28,030 --> 00:10:29,269
A の各行から算出され

300
00:10:29,269 --> 00:10:30,522
A の各行も

301
00:10:30,522 --> 00:10:32,113
やはり合計が 369 になる。

302
00:10:32,113 --> 00:10:34,485
では、ここで

303
00:10:34,500 --> 00:10:35,934
A の対角線上の要素も合計しよう。

304
00:10:35,990 --> 00:10:37,362
そして、この場合も、やはり

305
00:10:37,370 --> 00:10:39,696
合計が同じ数字になるか確認する。

306
00:10:39,730 --> 00:10:40,924
ここで私がお見せするのは、

307
00:10:40,924 --> 00:10:42,613
まず、最初に 9 x 9 の

308
00:10:42,613 --> 00:10:44,325
単位行列を作成する。

309
00:10:44,360 --> 00:10:46,018
それは eye(9) だ。

310
00:10:46,018 --> 00:10:49,326
A に対し、作成、いや乗算を

311
00:10:49,326 --> 00:10:51,272
要素単位で行う。

312
00:10:51,300 --> 00:10:52,812
だからここに 行列 A があり、

313
00:10:52,812 --> 00:10:56,350
そして A . eye(9) とする。

314
00:10:56,490 --> 00:10:58,018
これは、

315
00:10:58,020 --> 00:11:00,035
この二つの行列の

316
00:11:00,035 --> 00:11:01,150
要素単位の乗算を行い、

317
00:11:01,150 --> 00:11:03,605
その結果、対角線上の要素以外は

318
00:11:03,680 --> 00:11:06,421
すべてゼロになる。

319
00:11:06,421 --> 00:11:08,761
そこで、このように sum(sum(A.<i>eye(9)))</i>と

320
00:11:08,780 --> 00:11:11,179
合計の合計をすると、

321
00:11:11,180 --> 00:11:14,512
その結果は、対角線上の

322
00:11:14,512 --> 00:11:16,684
要素の合計で、本当に 369 だ。

323
00:11:16,684 --> 00:11:20,218
もう一つの対角線も合計できる。

324
00:11:20,240 --> 00:11:22,385
だから、この左上から右下に対し

325
00:11:22,400 --> 00:11:24,158
その反対の対角線を

326
00:11:24,180 --> 00:11:26,832
左下から右上にかけて合計する。

327
00:11:26,832 --> 00:11:30,199
この sum コマンドはすこし分かりにくく、

328
00:11:30,200 --> 00:11:31,535
これを覚える必要はないが、

329
00:11:31,540 --> 00:11:33,122
興味のある方のために、

330
00:11:33,122 --> 00:11:34,779
お見せしたいと思う。

331
00:11:34,779 --> 00:11:37,543
ではやってみる。

332
00:11:37,600 --> 00:11:41,235
flipud は flip up/down（上下反転） の略で、

333
00:11:41,235 --> 00:11:42,622
これを実行すると、

334
00:11:42,622 --> 00:11:44,376
反対の対角線上の

335
00:11:44,376 --> 00:11:46,055
要素を合計してくれる。

336
00:11:46,055 --> 00:11:49,387
その結果も、やはり 369 だ。

337
00:11:49,390 --> 00:11:51,116
では、具体的に見せる。

338
00:11:51,120 --> 00:11:53,055
eye(9) はこの行列で、

339
00:11:53,070 --> 00:11:57,300
eye(9) の flip up/down

340
00:11:57,370 --> 00:11:58,986
は、この単位行列を

341
00:11:58,986 --> 00:12:00,832
上下に反転する。

342
00:12:00,832 --> 00:12:01,822
すると、その結果、失礼、

343
00:12:01,822 --> 00:12:04,394
flip UD だった、結果は、

344
00:12:04,400 --> 00:12:08,742
反対の対角線上に 1 が並ぶ。

345
00:12:08,770 --> 00:12:10,430
最後にもう一つだけコマンドを紹介して

346
00:12:10,490 --> 00:12:12,706
このビデオを締めくくる。

347
00:12:12,760 --> 00:12:13,730
A を例えばまた

348
00:12:13,730 --> 00:12:16,112
3 x 3 の魔方陣とする。

349
00:12:16,112 --> 00:12:17,221
この行列の

350
00:12:17,221 --> 00:12:18,493
逆行列を戻す場合、

351
00:12:18,493 --> 00:12:20,668
pinv(A) と入力する。

352
00:12:20,668 --> 00:12:23,612
厳密には擬似逆行列といわれるが、さほど重要ではない。

353
00:12:23,612 --> 00:12:24,991
これを A の逆行列と基本的に考えてよい。

354
00:12:24,991 --> 00:12:26,927
そしてこれが

355
00:12:26,960 --> 00:12:28,313
A の逆行列なので、

356
00:12:28,313 --> 00:12:31,721
temp = pinv(A) と指定し

357
00:12:31,740 --> 00:12:33,596
そして temp A とすると、

358
00:12:33,596 --> 00:12:35,362
その結果は確かに

359
00:12:35,362 --> 00:12:37,252
単位行列で、実質的に 1 が対角線上に、

360
00:12:37,260 --> 00:12:38,753
0 が対角線以外に

361
00:12:38,753 --> 00:12:43,322
丸め誤差の範囲で並ぶ。

362
00:12:44,120 --> 00:12:45,746
さて、ここまでで、行列に含まれるデータに対し

363
00:12:45,750 --> 00:12:48,430
異なる演算処理を行う方法については

364
00:12:48,430 --> 00:12:50,865
終わりだ。

365
00:12:50,890 --> 00:12:53,055
学習アルゴリズムを

366
00:12:53,055 --> 00:12:54,350
実行した後にできる

367
00:12:54,380 --> 00:12:55,876
最も有意義なことの一つは、

368
00:12:55,900 --> 00:12:57,223
多くの場合、結果を見て、

369
00:12:57,230 --> 00:13:00,013
プロットし、結果を可視化することだ。

370
00:13:00,020 --> 00:13:01,675
そこで、次のビデオで、

371
00:13:01,675 --> 00:13:03,233
手短にお見せするのは、

372
00:13:03,233 --> 00:13:04,230
Octave を使って

373
00:13:04,300 --> 00:13:06,261
数行のコードだけで、

374
00:13:06,270 --> 00:13:07,814
手早くデータを可視化し、

375
00:13:07,850 --> 00:13:09,901
データをプロットに出力することだ。

376
00:13:09,901 --> 00:13:11,101
そして、それを使って、

377
00:13:11,101 --> 00:13:14,880
学習アルゴリズムの動きを理解してほしい。
