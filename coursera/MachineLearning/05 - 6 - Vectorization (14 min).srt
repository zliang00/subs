1
00:00:00,280 --> 00:00:04,479
このビデオでは、ベクトル式記法という概念について説明する。

2
00:00:04,480 --> 00:00:06,471
Octave や類似した言語

3
00:00:06,471 --> 00:00:08,277
MATLAB や

4
00:00:08,277 --> 00:00:09,604
Python および NumPy

5
00:00:09,604 --> 00:00:12,520
あるいは Java、C、C++ を使っていても、

6
00:00:12,520 --> 00:00:14,850
これらの言語には、

7
00:00:14,850 --> 00:00:16,708
既に内蔵されているか、

8
00:00:16,720 --> 00:00:19,439
またはすぐに簡単に入手可能な

9
00:00:19,439 --> 00:00:21,806
数値線形代数ライブラリがある。

10
00:00:21,820 --> 00:00:23,335
通常、これらは非常によく書かれており、

11
00:00:23,335 --> 00:00:25,695
高度に最適化され、多くの場合、

12
00:00:25,695 --> 00:00:29,181
数値計算の分野で博士号を持つか、

13
00:00:29,181 --> 00:00:32,075
数値計算に本当に特化した人たちが開発している。

14
00:00:32,075 --> 00:00:33,944
機械学習アルゴリズムを

15
00:00:33,960 --> 00:00:35,904
実装する時に、

16
00:00:35,930 --> 00:00:37,797
こうした線形代数ライブラリや、

17
00:00:37,810 --> 00:00:39,296
こうした数値線形代数を

18
00:00:39,310 --> 00:00:41,600
活用し、

19
00:00:41,620 --> 00:00:43,387
これらのルーチンを呼び出して、

20
00:00:43,387 --> 00:00:45,172
こうしたライブラリが使えれば、

21
00:00:45,180 --> 00:00:48,029
自分でコードを書かなくても、

22
00:00:48,040 --> 00:00:49,612
コードはさらに

23
00:00:49,612 --> 00:00:51,872
効率的になる。

24
00:00:51,880 --> 00:00:53,179
さらに実行速度が速くなり、

25
00:00:53,179 --> 00:00:54,891
自分のコンピュータに載っている

26
00:00:54,891 --> 00:00:56,631
並列処理ハードウェアを

27
00:00:56,631 --> 00:00:58,254
さらに利用できる。

28
00:00:58,270 --> 00:01:00,533
そして二番目に、

29
00:01:00,540 --> 00:01:03,075
自分で書くコードの量も少なくなる。

30
00:01:03,075 --> 00:01:04,962
つまり、実装が簡素になり、

31
00:01:04,962 --> 00:01:08,532
バグも減らせる可能性もある。

32
00:01:08,550 --> 00:01:10,534
そして、具体的な例で、

33
00:01:10,570 --> 00:01:12,726
行列の乗算をするのに

34
00:01:12,726 --> 00:01:15,061
自分でコードを書かないで、

35
00:01:15,061 --> 00:01:16,300
Octave にやらせて

36
00:01:16,300 --> 00:01:18,145
a  b と入力すると、

37
00:01:18,145 --> 00:01:19,833
非常に効率的なルーチンを使って、

38
00:01:19,833 --> 00:01:22,318
二つの行列の乗算をする。

39
00:01:22,340 --> 00:01:23,985
そして、こうした例は他にもいくつもあり、

40
00:01:24,010 --> 00:01:27,220
適切なベクトル式化された実装方法を使えば、

41
00:01:27,220 --> 00:01:30,062
コードが簡素になり、コードがより効率的になる。

42
00:01:30,280 --> 00:01:33,071
では、いくつか例を見てみる。

43
00:01:33,071 --> 00:01:34,937
これは、通常の線形回帰の

44
00:01:34,937 --> 00:01:36,415
仮説だ。

45
00:01:36,415 --> 00:01:37,348
h(x) を計算したい場合は、

46
00:01:37,348 --> 00:01:40,032
例のように、右辺では合計をする。

47
00:01:40,032 --> 00:01:41,130
一つのやり方は、

48
00:01:41,130 --> 00:01:42,775
j=0 から j=n までの

49
00:01:42,775 --> 00:01:46,611
合計を自分で計算することだ。

50
00:01:46,620 --> 00:01:48,000
もう一つの考え方は、

51
00:01:48,000 --> 00:01:49,210
h(x) を

52
00:01:49,210 --> 00:01:52,029
theta の転置行列と x との乗算でやることだ。

53
00:01:52,029 --> 00:01:53,262
ここで

54
00:01:53,262 --> 00:01:55,654
二つのベクトルの

55
00:01:55,660 --> 00:01:57,823
内積を計算する、と考える。

56
00:01:57,840 --> 00:02:00,135
ここでは theta は、

57
00:02:00,135 --> 00:02:01,784
二つの特徴がある場合、ベクトルは

58
00:02:01,800 --> 00:02:04,812
theta 0、theta 1、theta 2 となる。

59
00:02:04,812 --> 00:02:06,410
その場合は n = 2 だ。

60
00:02:06,450 --> 00:02:08,133
そして x はこのような

61
00:02:08,133 --> 00:02:11,810
ベクトルになる x 0、x 1、x 2

62
00:02:11,884 --> 00:02:13,952
そしてこの二つの見方は、

63
00:02:13,952 --> 00:02:17,539
二通りの実装方法につながる。

64
00:02:17,560 --> 00:02:18,909
どういうことかと言うと、

65
00:02:18,909 --> 00:02:21,012
ここに非ベクトル式記法の

66
00:02:21,040 --> 00:02:22,454
h(x) の演算方法の実装がある。

67
00:02:22,454 --> 00:02:26,120
非ベクトル式記法とは、ベクトル式化されていない、という意味だ。

68
00:02:26,130 --> 00:02:29,479
最初に prediction を 0.0 に初期化する。

69
00:02:29,479 --> 00:02:32,383
これ、prediction は、

70
00:02:32,383 --> 00:02:34,287
そのうちに

71
00:02:34,300 --> 00:02:36,090
h(x) になる。そして

72
00:02:36,090 --> 00:02:37,258
for ループで

73
00:02:37,270 --> 00:02:38,354
j = 1 から n+1 とする。

74
00:02:38,354 --> 00:02:40,792
prediction は

75
00:02:40,792 --> 00:02:41,822
theta(j)  x(j) でインクリメントされる。

76
00:02:41,822 --> 00:02:44,737
これは、この式に相当する。

77
00:02:44,737 --> 00:02:47,223
ところで、触れておくべき点として、

78
00:02:47,223 --> 00:02:48,894
この右上のベクトルだが、

79
00:02:48,900 --> 00:02:51,102
ここでは インデックスが 0 から始めている。

80
00:02:51,110 --> 00:02:52,600
だから、theta 0、theta 1

81
00:02:52,600 --> 00:02:54,390
theta 2、としていたが、MATLAB では

82
00:02:54,390 --> 00:02:56,713
インデックスは 1 からなので、theta 0 を

83
00:02:56,713 --> 00:02:58,019
MATLAB では表現方法を

84
00:02:58,019 --> 00:03:00,204
変えて theta 1 とし、

85
00:03:00,204 --> 00:03:02,042
この二番目の要素は

86
00:03:02,042 --> 00:03:04,392
theta 2 になり

87
00:03:04,392 --> 00:03:05,862
三番目の要素は

88
00:03:05,880 --> 00:03:08,002
theta 3 となる。

89
00:03:08,002 --> 00:03:09,952
これは単に MATLAB では

90
00:03:09,960 --> 00:03:11,998
ベクトルのインデックスは

91
00:03:11,998 --> 00:03:13,525
1 から始まるのに対し、

92
00:03:13,525 --> 00:03:15,436
本来の theta および x は

93
00:03:15,450 --> 00:03:17,002
0 からインデックスが始まるからだ。

94
00:03:17,002 --> 00:03:18,785
これが理由で、ここの for ループでは

95
00:03:18,785 --> 00:03:20,498
j は 1 から n+1 に進み、

96
00:03:20,498 --> 00:03:22,225
j が 0 から n へは進まない。

97
00:03:22,225 --> 00:03:26,243
わかったかな？

98
00:03:26,300 --> 00:03:27,870
ということで、これは

99
00:03:27,870 --> 00:03:29,571
非ベクトル式記法の実装方法で、

100
00:03:29,571 --> 00:03:31,373
n 要素の合計を行うために、

101
00:03:31,373 --> 00:03:34,018
for ループを使っている。

102
00:03:34,050 --> 00:03:35,646
それとは対照的に、

103
00:03:35,646 --> 00:03:38,400
ここにベクトル式化された実装方法の書き方、

104
00:03:38,410 --> 00:03:39,959
つまり、

105
00:03:39,959 --> 00:03:42,618
x および theta を

106
00:03:42,618 --> 00:03:43,955
ベクトルとして考え、

107
00:03:43,955 --> 00:03:46,039
prediction に theta の転置行列と

108
00:03:46,039 --> 00:03:48,347
x との乗算を代入する。

109
00:03:48,360 --> 00:03:51,011
for ループを使って、

110
00:03:51,011 --> 00:03:52,966
何行ものコードを書かずに、

111
00:03:52,966 --> 00:03:54,242
たったの一行の

112
00:03:54,242 --> 00:03:56,648
コードで済む。そして

113
00:03:56,648 --> 00:03:57,555
この右の一行のコードは

114
00:03:57,555 --> 00:03:59,237
Octave の

115
00:03:59,237 --> 00:04:01,829
高度に最適化された数値

116
00:04:01,840 --> 00:04:03,859
線形代数ルーチンを使って

117
00:04:03,859 --> 00:04:06,245
二つのベクトル theta と x の

118
00:04:06,245 --> 00:04:08,186
内積を算出する。

119
00:04:08,190 --> 00:04:10,182
単にベクトル式化された実装の方が

120
00:04:10,182 --> 00:04:14,664
簡素なだけでなく、より効率的に実行される。

121
00:04:15,820 --> 00:04:17,792
さて、これは Octave だが、

122
00:04:17,792 --> 00:04:19,912
ベクトル式記法は

123
00:04:19,920 --> 00:04:22,020
他のプログラミング言語でも適用可能だ。

124
00:04:22,040 --> 00:04:24,947
では C++ の例をみてみる。

125
00:04:24,947 --> 00:04:27,965
ここに非ベクトル式記法の実装例がある。

126
00:04:27,965 --> 00:04:31,395
ここでも prediction を 0.0 に初期化し

127
00:04:31,395 --> 00:04:32,518
この場合のループは

128
00:04:32,518 --> 00:04:34,508
j=0 から n の範囲となる。

129
00:04:34,508 --> 00:04:36,819
prediction +=

130
00:04:36,830 --> 00:04:38,546
theta[j]  x[j]; ここでも

131
00:04:38,560 --> 00:04:42,777
この明示的な for ループを自分で書くことになる。

132
00:04:42,777 --> 00:04:44,843
対照的に、C++ でも

133
00:04:44,850 --> 00:04:46,498
良い数値線形代数ライブラリを

134
00:04:46,498 --> 00:04:48,965
使うと、ここでもこのような

135
00:04:48,990 --> 00:04:54,440
関数を書くことができる。

136
00:04:54,560 --> 00:04:56,533
むしろ対照的に、C++ でも

137
00:04:56,533 --> 00:04:58,152
良い数値線形代数ライブラリを使うと、

138
00:04:58,152 --> 00:05:00,686
代わりに

139
00:05:00,686 --> 00:05:02,470
次のようなコードが書ける。

140
00:05:02,470 --> 00:05:03,985
使っている数値線形代数

141
00:05:03,985 --> 00:05:05,595
ライブラリにより

142
00:05:05,595 --> 00:05:06,790
詳細は異なるが、

143
00:05:06,830 --> 00:05:08,580
C++ の

144
00:05:08,580 --> 00:05:09,918
オブジェクトとして

145
00:05:09,918 --> 00:05:11,328
ベクトル theta と

146
00:05:11,350 --> 00:05:13,436
C++ オブジェクトとしてベクトル x が定義され、

147
00:05:13,436 --> 00:05:15,552
そして単に theta.transpose() に

148
00:05:15,552 --> 00:05:18,115
対して x の乗算をする。

149
00:05:18,120 --> 00:05:20,092
この乗算演算子は、

150
00:05:20,092 --> 00:05:22,028
C++ でオーバーロードされた演算子であり、

151
00:05:22,028 --> 00:05:26,156
C++ でも二つのベクトル乗算ができる。

152
00:05:26,156 --> 00:05:28,091
使っている数値線形代数の

153
00:05:28,110 --> 00:05:29,515
ライブラリの詳細によっては、

154
00:05:29,515 --> 00:05:30,855
多少、構文が

155
00:05:30,855 --> 00:05:31,894
異なるかもしれないが、

156
00:05:31,894 --> 00:05:33,636
ライブラリを利用して

157
00:05:33,636 --> 00:05:35,758
この内積を行うことで

158
00:05:35,760 --> 00:05:37,064
コードを非常に簡素化でき、

159
00:05:37,064 --> 00:05:40,623
さらに非常に効率的にもなる。

160
00:05:40,623 --> 00:05:43,582
ではさらに詳細な例を見てみよう。

161
00:05:43,582 --> 00:05:45,015
念のため、ここに

162
00:05:45,015 --> 00:05:46,792
線形回帰の場合の

163
00:05:46,792 --> 00:05:48,794
最急降下法の更新ルールがある。

164
00:05:48,794 --> 00:05:50,488
だから theta j をこの

165
00:05:50,488 --> 00:05:53,672
ルールを使ってすべての j の値で更新する。 j=0、1、2、という風に。

166
00:05:53,672 --> 00:05:56,259
そして、これを

167
00:05:56,260 --> 00:05:58,206
theta 0、 theta 1、 theta 2 を使って

168
00:05:58,206 --> 00:06:00,048
式で表すと、こうなる。

169
00:06:00,048 --> 00:06:02,173
前提は、特徴数が２つだ。

170
00:06:02,173 --> 00:06:03,469
だから n=2 だ。

171
00:06:03,469 --> 00:06:04,607
よって、これが私たちが theta 0、

172
00:06:04,610 --> 00:06:07,388
theta 1、theta 2 に適用する更新だ。

173
00:06:07,410 --> 00:06:08,982
そして、私が前のビデオで

174
00:06:08,982 --> 00:06:10,825
言ったが、

175
00:06:10,825 --> 00:06:14,783
同時更新でなくてはならない。

176
00:06:14,783 --> 00:06:16,268
では、この

177
00:06:16,268 --> 00:06:17,725
ベクトル式化された実装が動くか、

178
00:06:17,725 --> 00:06:20,723
試してみよう。

179
00:06:20,740 --> 00:06:22,598
ここに、先ほどと同じ三つの式が

180
00:06:22,598 --> 00:06:24,182
やや小さめのフォントで表示されている。

181
00:06:24,182 --> 00:06:25,517
この三行のコードを

182
00:06:25,520 --> 00:06:26,716
実装するのに

183
00:06:26,720 --> 00:06:27,798
思いつく方法は、１つは、

184
00:06:27,798 --> 00:06:28,968
for ループを使って、

185
00:06:28,968 --> 00:06:31,682
for j = 0;

186
00:06:31,682 --> 00:06:33,305
1 から 2 で theta j を更新、

187
00:06:33,305 --> 00:06:35,603
というようなやり方だ。

188
00:06:35,603 --> 00:06:36,760
しかしその代わりに、

189
00:06:36,760 --> 00:06:40,975
ベクトル式化された実装を考え、より簡素化できるか見てみよう。

190
00:06:40,975 --> 00:06:42,711
つまり、基本的には、これらの三行のコードの、

191
00:06:42,757 --> 00:06:44,314
この三つのステップを、１ステップごとに処理している、

192
00:06:44,314 --> 00:06:48,518
for ループを圧縮することだ。

193
00:06:48,518 --> 00:06:49,688
では、これら三つの

194
00:06:49,688 --> 00:06:51,402
ステップを 1 行の、ベクトル式化された

195
00:06:51,402 --> 00:06:53,972
コードに圧縮できるか見てみよう。

196
00:06:53,976 --> 00:06:55,476
これがその考え方だ。

197
00:06:55,480 --> 00:06:55,480


198
00:06:55,480 --> 00:06:59,131
まず、theta を

199
00:06:59,131 --> 00:07:00,633
ベクトルと見なし、

200
00:07:00,633 --> 00:07:04,214
theta をこのように更新する: 

201
00:07:04,270 --> 00:07:07,468
theta 引く alpha 掛ける別の

202
00:07:07,468 --> 00:07:11,650
ベクトル delta、そして

203
00:07:11,650 --> 00:07:13,689
delta は

204
00:07:13,700 --> 00:07:15,876
= 1/m

205
00:07:15,876 --> 00:07:18,408
和は i=

206
00:07:18,450 --> 00:07:22,151
1 から m までの合計、そして

207
00:07:22,180 --> 00:07:25,570
その右に、

208
00:07:25,720 --> 00:07:28,118
この項がある。いいかな？

209
00:07:28,118 --> 00:07:31,205
では、ここでやっていることを説明する。

210
00:07:31,220 --> 00:07:32,666
ここでは、

211
00:07:32,666 --> 00:07:35,322
theta をベクトルとして扱う。

212
00:07:35,350 --> 00:07:38,106
だから、これは n+1 次元ベクトルだ。

213
00:07:38,110 --> 00:07:40,291
theta が更新されるのは、

214
00:07:40,310 --> 00:07:43,922
これはベクトルだ、 R n+1

215
00:07:43,922 --> 00:07:45,319
alpha は実数だ。

216
00:07:45,319 --> 00:07:47,395
そしてこの delta は

217
00:07:47,410 --> 00:07:49,941
ベクトルだ。

218
00:07:49,960 --> 00:07:54,278
だから、これはベクトルの除算だ。

219
00:07:54,278 --> 00:07:55,255
いいかな？

220
00:07:55,255 --> 00:07:56,977
なぜなら、alpha 掛ける delta は

221
00:07:56,977 --> 00:07:58,385
ベクトルだからだ。

222
00:07:58,385 --> 00:08:00,369
つまり theta から

223
00:08:00,369 --> 00:08:04,217
このベクトル、alpha 掛ける detla を引くのだ。

224
00:08:04,240 --> 00:08:06,563
では、ベクトル delta は何だろうか？

225
00:08:06,563 --> 00:08:10,220
このベクトル delta はこうだ。

226
00:08:10,256 --> 00:08:12,092
そして、

227
00:08:12,092 --> 00:08:14,595
実際には、

228
00:08:14,620 --> 00:08:17,102
この部分と同じだ。

229
00:08:17,140 --> 00:08:19,200
具体的には、delta は

230
00:08:19,220 --> 00:08:22,165
n+1 次元ベクトルで、

231
00:08:22,165 --> 00:08:23,978
ベクトル delta の

232
00:08:23,978 --> 00:08:27,767
一番最初の要素は、これと同等になる。

233
00:08:27,770 --> 00:08:29,513
だから、

234
00:08:29,513 --> 00:08:31,565
delta は、0 からインデックスすると

235
00:08:31,565 --> 00:08:34,469
これが delta 0、delta 2、delta 2 だ。

236
00:08:34,469 --> 00:08:36,541
私が望むことは、

237
00:08:36,560 --> 00:08:39,033
この delta 0 が

238
00:08:39,040 --> 00:08:41,267
この上の方の最初の緑色で

239
00:08:41,267 --> 00:08:42,359
囲んだところと同等になること。

240
00:08:42,360 --> 00:08:45,306
そして、

241
00:08:45,306 --> 00:08:47,108
こうして確認できる。

242
00:08:47,108 --> 00:08:48,681
delta 0 = 1/m

243
00:08:48,681 --> 00:08:50,102
h(x) の合計、

244
00:08:50,102 --> 00:08:53,356
x(i) 引く

245
00:08:53,400 --> 00:08:58,315
y(i) 掛ける x(i) 0。

246
00:08:58,315 --> 00:08:59,748
では、確認のために

247
00:08:59,748 --> 00:09:01,064
皆さんと共通理解があるか

248
00:09:01,064 --> 00:09:03,998
delta の実際の計算方法をおさらいする。

249
00:09:03,998 --> 00:09:05,488
delta は、1/m

250
00:09:05,488 --> 00:09:08,284
掛ける この総和だ。

251
00:09:08,284 --> 00:09:09,871
そして、この総和は何だろうか？

252
00:09:09,871 --> 00:09:11,426
ここにあるこの項、

253
00:09:11,426 --> 00:09:17,115
これは実数だ。

254
00:09:17,150 --> 00:09:21,219
そしてこの二つ目の項、x(i)

255
00:09:21,219 --> 00:09:23,892
ここにあるこの項は

256
00:09:23,910 --> 00:09:26,109
ベクトルだ。なぜなら、x(i) は

257
00:09:26,109 --> 00:09:26,982
ベクトルで、

258
00:09:26,990 --> 00:09:29,630
その中身は

259
00:09:29,975 --> 00:09:36,115
x(i) 0、x(i) 1、x(i) 2、だからだ。

260
00:09:36,130 --> 00:09:38,246
そして総和は何だろうか？

261
00:09:38,246 --> 00:09:40,241
総和がやることは、

262
00:09:40,250 --> 00:09:43,292
こちらの

263
00:09:43,502 --> 00:09:46,555
この項

264
00:09:47,280 --> 00:09:54,801
これは = h(x(1)) - y(1) 掛ける

265
00:09:54,870 --> 00:09:59,099
x(1) + h(x(2))

266
00:09:59,115 --> 00:10:02,778
-y(2) 掛ける x(2)

267
00:10:02,778 --> 00:10:05,396
+ と続く。

268
00:10:05,396 --> 00:10:06,404
いいかな？

269
00:10:06,404 --> 00:10:07,420
なぜなら、これは i に対する

270
00:10:07,420 --> 00:10:09,013
総和なので、i は

271
00:10:09,013 --> 00:10:11,345
i=1 から m の範囲で進む。

272
00:10:11,345 --> 00:10:15,144
こうして別々の項を算出して、それを合計する。

273
00:10:15,160 --> 00:10:16,221
そして、こうした項の

274
00:10:16,221 --> 00:10:18,262
意味は、

275
00:10:18,262 --> 00:10:19,807
もし、まだ覚えていれば、

276
00:10:19,807 --> 00:10:24,100
以前、問題でこの式を見たと思う。

277
00:10:24,110 --> 00:10:25,560
その時に、このコードを

278
00:10:25,560 --> 00:10:27,250
ベクトル式化するには

279
00:10:27,250 --> 00:10:30,755
代わりに u = 2v+5w とする、と言った。

280
00:10:30,770 --> 00:10:32,391
この意味は、ベクトル u が

281
00:10:32,391 --> 00:10:33,706
2 掛ける

282
00:10:33,706 --> 00:10:35,568
ベクトル v 足す 5 掛ける

283
00:10:35,570 --> 00:10:37,198
ベクトル w。

284
00:10:37,198 --> 00:10:39,023
これは単に、例として、

285
00:10:39,023 --> 00:10:42,453
別々のベクトルを加算したが、この総和も同じだ。

286
00:10:42,453 --> 00:10:44,919
私が言いたいのは、

287
00:10:44,950 --> 00:10:49,766
ここにある総和は、ある実数、だ。

288
00:10:49,840 --> 00:10:50,996
これは 2 とかそれ以外の

289
00:10:51,010 --> 00:10:52,698
なんらかの数字だ。

290
00:10:52,711 --> 00:10:54,085
それ掛けるベクトル x1。

291
00:10:54,085 --> 00:10:56,792
これは 2 掛ける v のようだが、

292
00:10:56,792 --> 00:10:59,177
代わりに何か別の数字掛ける x1

293
00:10:59,177 --> 00:11:01,712
それ足す、

294
00:11:01,712 --> 00:11:03,475
5 掛ける w の代わりに、

295
00:11:03,475 --> 00:11:05,212
何か他の実数足す何か

296
00:11:05,212 --> 00:11:06,850
別のベクトルを行い、次に

297
00:11:06,860 --> 00:11:08,909
その上に他のベクトルを加算していく。

298
00:11:08,909 --> 00:11:10,528
足す... 足す他の

299
00:11:10,540 --> 00:11:12,234
ベクトル、これが

300
00:11:12,234 --> 00:11:15,178
全体的には、ここにある

301
00:11:15,178 --> 00:11:17,015
これは、この全体の

302
00:11:17,015 --> 00:11:19,745
量、この delta が

303
00:11:19,770 --> 00:11:23,685
単なるなんらかのベクトルとなる理由だ。

304
00:11:23,685 --> 00:11:26,373
具体的には、delta の三つの要素は

305
00:11:26,373 --> 00:11:28,813
もし n=2なら、delta の

306
00:11:28,820 --> 00:11:31,512
三つの要素は正に

307
00:11:31,512 --> 00:11:33,349
これと、この二番目の

308
00:11:33,349 --> 00:11:35,075
これと、三番目の

309
00:11:35,075 --> 00:11:36,401
これに対応する。これが

310
00:11:36,410 --> 00:11:38,299
theta を更新する時に、

311
00:11:38,299 --> 00:11:40,979
theta - alpha   delta に従うと、

312
00:11:41,010 --> 00:11:42,760
上記の更新ルールの通りに

313
00:11:42,830 --> 00:11:44,948
正に同じ同時更新が

314
00:11:44,960 --> 00:11:47,825
行われる理由だ。

315
00:11:47,840 --> 00:11:48,960
このスライドでは、説明が、

316
00:11:48,960 --> 00:11:50,466
かなりの量になってしまった。

317
00:11:50,500 --> 00:11:52,608
ここでも

318
00:11:52,650 --> 00:11:54,489
遠慮なくビデオを止めて、

319
00:11:54,510 --> 00:11:56,592
順番に違いを見ていくことを

320
00:11:56,592 --> 00:11:58,247
お勧めする。もし

321
00:11:58,247 --> 00:11:59,451
今の説明がよくわからなければ、

322
00:11:59,451 --> 00:12:01,719
スライドを順番に見て

323
00:12:01,719 --> 00:12:02,940
各ステップの理由を理解できているか

324
00:12:02,940 --> 00:12:04,578
確認して欲しい。

325
00:12:04,580 --> 00:12:07,048
ここにある、この更新、

326
00:12:07,060 --> 00:12:09,612
この delta の定義、がなぜこうなるのか。

327
00:12:09,612 --> 00:12:10,943
なぜこれが上の方の

328
00:12:10,943 --> 00:12:13,714
更新と同じなのか。

329
00:12:13,714 --> 00:12:15,033
それでも分からない場合は、一つの洞察は、

330
00:12:15,033 --> 00:12:18,395
ここにあるこれは、

331
00:12:18,400 --> 00:12:20,628
正にベクトル x だ、

332
00:12:20,628 --> 00:12:22,109
ということだ。

333
00:12:22,109 --> 00:12:23,342
だから、この三つ全ての

334
00:12:23,342 --> 00:12:25,516
演算処理を圧縮して

335
00:12:25,516 --> 00:12:27,106
このベクトルのデータで

336
00:12:27,106 --> 00:12:29,778
一つのステップにしている。

337
00:12:29,778 --> 00:12:31,292
これが、

338
00:12:31,292 --> 00:12:33,465
このステップ、の線形回帰の

339
00:12:33,490 --> 00:12:36,942
ベクトル式化された実装を導くことができた理由だ。

340
00:12:36,942 --> 00:12:38,639
だから、このステップを

341
00:12:38,660 --> 00:12:40,660
理解してもらいたいので、

342
00:12:40,660 --> 00:12:41,791
ビデオを見返して、理解できているか

343
00:12:41,791 --> 00:12:44,013
確認してほしい。

344
00:12:44,013 --> 00:12:46,058
もし、この計算の

345
00:12:46,058 --> 00:12:48,029
等価性が理解できない場合、

346
00:12:48,029 --> 00:12:49,435
これを実装すると、

347
00:12:49,435 --> 00:12:50,944
これは正しい答えを出力するので

348
00:12:50,944 --> 00:12:52,224
たとえ等価性を理解できていなくても、

349
00:12:52,224 --> 00:12:56,403
ただこの通りに実装すれば

350
00:12:56,410 --> 00:12:58,992
線形回帰が動作するはずだ。

351
00:12:58,992 --> 00:13:00,663
そして、もし

352
00:13:00,663 --> 00:13:02,216
この二つのステップが

353
00:13:02,216 --> 00:13:04,122
等価であることを理解できた場合は、

354
00:13:04,122 --> 00:13:06,239
ベクトル式化についても、理解を深めた

355
00:13:06,239 --> 00:13:10,121
ことになる。そして最後に、

356
00:13:10,121 --> 00:13:12,355
もし 1 あるいは 2 以上の特徴を使って

357
00:13:12,370 --> 00:13:14,872
線形回帰を実装する場合は、

358
00:13:14,872 --> 00:13:16,548
線形回帰では、

359
00:13:16,550 --> 00:13:18,078
時折、1万、あるいは 10 万もの

360
00:13:18,078 --> 00:13:19,968
特徴を使うことがある。

361
00:13:19,980 --> 00:13:21,853
しかし、ベクトル式化された線形回帰の

362
00:13:21,853 --> 00:13:23,735
の実装を使えば、

363
00:13:23,735 --> 00:13:25,605
通常、例えばお馴染みの

364
00:13:25,605 --> 00:13:26,892
for ループを使った場合と比べて、

365
00:13:26,892 --> 00:13:28,163
つまり、自分で theta 0 の次に theta 1、

366
00:13:28,163 --> 00:13:31,485
次に theta 2 と更新するより実行速度が速い。

367
00:13:31,500 --> 00:13:33,769
だから、ベクトル式化された実装を使うことで

368
00:13:33,769 --> 00:13:34,688
より効率的な線形回帰の実装が

369
00:13:34,688 --> 00:13:37,762
可能になる。

370
00:13:37,790 --> 00:13:39,347
そして、その後の

371
00:13:39,347 --> 00:13:40,430
クラスで見る

372
00:13:40,430 --> 00:13:41,554
アルゴリズムをベクトル式化すると

373
00:13:41,554 --> 00:13:43,367
それは Octave でも

374
00:13:43,367 --> 00:13:44,767
それ以外の C++ や Java のような言語であも、

375
00:13:44,767 --> 00:13:48,474
コードをより効率的に実行するための有効な技術になる。
