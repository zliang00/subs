1
00:00:00,111 --> 00:00:02,628
この二番目のOctaveチュートリアルビデオでは、

2
00:00:02,630 --> 00:00:03,904
Octave でのデータの

3
00:00:03,930 --> 00:00:07,322
取り扱いについて、説明する。

4
00:00:07,340 --> 00:00:08,783
機械学習問題用のデータを、

5
00:00:08,783 --> 00:00:12,125
Octave に読み込む方法。

6
00:00:12,125 --> 00:00:13,693
行列に取り込む方法。

7
00:00:13,693 --> 00:00:15,284
行列を取り扱う方法。

8
00:00:15,290 --> 00:00:16,982
結果を保存する方法。

9
00:00:17,000 --> 00:00:22,185
データを出し入れし、演算を行う方法。

10
00:00:22,900 --> 00:00:25,044
ここある Octave ウィンドウは

11
00:00:25,044 --> 00:00:29,256
前回のビデオで使ったままで、ここから続ける。

12
00:00:29,290 --> 00:00:31,132
A と入力すると、それは

13
00:00:31,140 --> 00:00:32,258
前に作成した行列だ。

14
00:00:32,258 --> 00:00:35,197
このコマンドで、= 1、2、

15
00:00:35,197 --> 00:00:38,152
3、4、 5、 6、すると

16
00:00:38,190 --> 00:00:40,696
これは 3 x 2 の行列だ。

17
00:00:40,710 --> 00:00:42,415
Octave の size コマンドを使うと

18
00:00:42,430 --> 00:00:46,361
その行列のサイズが、表示される。

19
00:00:46,361 --> 00:00:48,207
よってsize(A) は、 3、2 を 返す。

20
00:00:48,207 --> 00:00:50,160
実は、

21
00:00:50,180 --> 00:00:52,155
この size コマンドそのものが

22
00:00:52,155 --> 00:00:54,591
1 x 2 の行列を返す。

23
00:00:54,591 --> 00:00:56,598
だから、SZ = size(A) を

24
00:00:56,598 --> 00:00:58,370
実行すると、

25
00:00:58,380 --> 00:00:59,597
SZ は 1 x 2 の行列となり、

26
00:00:59,597 --> 00:01:01,627
最初の要素が 3、

27
00:01:01,640 --> 00:01:04,689
二番目の要素が 2 となる。

28
00:01:04,700 --> 00:01:07,494
そこで size(SZ) と入力すると、

29
00:01:07,494 --> 00:01:08,898
SZ は 1 x 2 の行列で、

30
00:01:08,898 --> 00:01:10,862
その二つの要素には

31
00:01:10,862 --> 00:01:13,721
行列 A の次元情報が含まれている。

32
00:01:13,721 --> 00:01:13,721


33
00:01:13,721 --> 00:01:17,787
また、size(A, 1)と入力すると

34
00:01:17,787 --> 00:01:19,505
返されるのは 、

35
00:01:19,510 --> 00:01:21,542
最初のA の次元のサイズ、

36
00:01:21,542 --> 00:01:22,662
Aの最初の次元のサイズだ。

37
00:01:22,680 --> 00:01:24,108
これは行の数だ。

38
00:01:24,110 --> 00:01:26,307
size(A, 2) の場合は

39
00:01:26,320 --> 00:01:28,361
2 が返される。

40
00:01:28,361 --> 00:01:29,598
これは行列 A の列の数だ。

41
00:01:29,598 --> 00:01:29,598


42
00:01:29,598 --> 00:01:34,034
もし、ベクトル V の場合は、

43
00:01:34,034 --> 00:01:36,016
例えば V = 1、2、3、4、

44
00:01:36,030 --> 00:01:38,089
そして

45
00:01:38,089 --> 00:01:40,830
length(V) と入力すると、

46
00:01:40,830 --> 00:01:42,097
この場合は、

47
00:01:42,097 --> 00:01:44,123
一番長い次元のサイズを返す。

48
00:01:44,170 --> 00:01:45,609
よって、

49
00:01:45,609 --> 00:01:48,487
length(A) と入力すると、

50
00:01:48,500 --> 00:01:49,856
A は 3 x 2の

51
00:01:49,860 --> 00:01:52,305
行列なので、

52
00:01:52,330 --> 00:01:53,825
長い方の次元のサイズは 3、


53
00:01:53,825 --> 00:01:56,145
よって 3 が出力されるはずだ。

54
00:01:56,145 --> 00:01:58,805
でも、通常は length はベクトルだけに使う。

55
00:01:58,810 --> 00:02:00,194
なので、length 1、2、

56
00:02:00,200 --> 00:02:02,222
3、4、と使うが、

57
00:02:02,230 --> 00:02:04,010
length を、行列には使わない。

58
00:02:04,010 --> 00:02:07,205
混乱する可能性があるためだ。

59
00:02:07,620 --> 00:02:10,122
では、ここで、どのように

60
00:02:10,122 --> 00:02:11,843
データを読み込み、データを

61
00:02:11,860 --> 00:02:13,732
ファイル システム上で見つけるかを説明する。

62
00:02:13,732 --> 00:02:15,254
Octave を起動すると

63
00:02:15,254 --> 00:02:16,882
通常、多くの場合、

64
00:02:16,920 --> 00:02:19,098
パスは

65
00:02:19,098 --> 00:02:21,738
Octave のある場所となる。

66
00:02:21,750 --> 00:02:24,042
そこで pwd コマンドを使うと、

67
00:02:24,060 --> 00:02:25,619
カレントディレクトリ、

68
00:02:25,640 --> 00:02:28,738
つまりOctave の現在のパスが表示される。

69
00:02:28,738 --> 00:02:31,932
だから、知らないディレクトリにいるかもしれない。

70
00:02:31,932 --> 00:02:33,999
cd コマンドは

71
00:02:34,000 --> 00:02:35,322
change directory の略で、

72
00:02:35,330 --> 00:02:40,681
ここで C:/Users/Ang/Desktop と入力すると、

73
00:02:40,681 --> 00:02:43,657
今いる場所がデスクトップになる。

74
00:02:43,657 --> 00:02:45,925
ls と入力すると、

75
00:02:45,925 --> 00:02:49,447
ちなみに、ls は、Unix あるいは Linux コマンドに由来する。

76
00:02:49,447 --> 00:02:50,648
ls はリストとして

77
00:02:50,648 --> 00:02:52,435
デスクトップ上のディレクトリを戻し、

78
00:02:52,435 --> 00:02:54,137
表示するので、

79
00:02:54,140 --> 00:02:58,184
これらが今、私のデスクトップにあるファイルだ。

80
00:03:15,850 --> 00:03:17,838
実際、私のデスクトップには

81
00:03:17,838 --> 00:03:19,920
二つのファイルがある。

82
00:03:19,920 --> 00:03:21,689
Features X と Price Y で、

83
00:03:21,689 --> 00:03:23,596
これは機械学習問題のデータだ。

84
00:03:23,620 --> 00:03:25,830
これが私のデスクトップだ。

85
00:03:25,830 --> 00:03:29,144
ここに Features X があり、

86
00:03:29,144 --> 00:03:31,598
Features X はこのウィンドウで、

87
00:03:31,630 --> 00:03:34,492
失礼、このファイルは二列のデータが含まれる。

88
00:03:34,492 --> 00:03:36,702
これが実際の住宅の価格のデータだ。

89
00:03:36,750 --> 00:03:38,374
確か、

90
00:03:38,374 --> 00:03:40,652
このデータセットは、47行ある。

91
00:03:40,652 --> 00:03:42,344
この最初の住宅の面積は

92
00:03:42,350 --> 00:03:43,966
2104平方フィート、

93
00:03:43,970 --> 00:03:46,172
寝室が三つある。

94
00:03:46,190 --> 00:03:47,367
二番目の 住宅は 1600平方フィート、

95
00:03:47,367 --> 00:03:49,862
寝室は三つ、というように続く。

96
00:03:49,880 --> 00:03:52,302
そして Price Y は、

97
00:03:52,302 --> 00:03:55,020
このファイルで、

98
00:03:55,040 --> 00:03:57,575
訓練セットの価格のデータだ。

99
00:03:57,575 --> 00:03:59,735
つまり、Features X と

100
00:03:59,735 --> 00:04:03,061
Price Y は、データを含む、単なるテキストファイルだ。

101
00:04:03,061 --> 00:04:04,770
このデータを Octave に、どのように読み込むか。

102
00:04:04,770 --> 00:04:06,050
単に、コマンドで、

103
00:04:06,090 --> 00:04:08,163
load Features X.dat と入力して、

104
00:04:08,163 --> 00:04:10,069
実行すると、

105
00:04:10,069 --> 00:04:11,991
Features X が読み込まれ、

106
00:04:11,991 --> 00:04:15,772
同様に Price Y.dat も読み込める。

107
00:04:15,772 --> 00:04:17,323
ちなみに、これには複数のやり方があり、

108
00:04:17,323 --> 00:04:19,245
このコマンドで、

109
00:04:19,245 --> 00:04:20,916
Features X.dat を、文字列として入力しても、

110
00:04:20,916 --> 00:04:22,533
同様に読み込める。

111
00:04:22,550 --> 00:04:25,477
打ち間違えた。

112
00:04:25,490 --> 00:04:27,317
これが同等のコマンドだ。

113
00:04:27,317 --> 00:04:29,334
このように、

114
00:04:29,360 --> 00:04:31,985
ファイル名の文字列として

115
00:04:32,000 --> 00:04:34,148
ファイル名を

116
00:04:34,148 --> 00:04:35,716
文字列として扱う。

117
00:04:35,716 --> 00:04:38,902
Octave では、シングル引用符を使って

118
00:04:38,930 --> 00:04:41,876
文字列を表す。こんな風に。

119
00:04:41,910 --> 00:04:42,837
だから、これは文字列だ。

120
00:04:42,860 --> 00:04:45,517
そして、ファイルを読み込むには

121
00:04:45,517 --> 00:04:48,324
その名前を、文字列として与える。

122
00:04:48,324 --> 00:04:50,919
さて、 who コマンド は、

123
00:04:50,960 --> 00:04:52,538
現在、どのような変数が

124
00:04:52,538 --> 00:04:54,605
Octave ワークスペースにあるか表示する。

125
00:04:54,605 --> 00:04:56,310
つまり、Who は  変数が

126
00:04:56,330 --> 00:04:59,952
現在 Octave のメモリに存在するかを示す。

127
00:04:59,952 --> 00:05:01,367
Features X と Price Y も

128
00:05:01,370 --> 00:05:02,991
そこに含まれていて、

129
00:05:02,991 --> 00:05:04,120
さらに、変数には、

130
00:05:04,170 --> 00:05:06,311
このセッションで、前に作成したものもある。

131
00:05:06,311 --> 00:05:09,198
従って、 Features X と入力すると

132
00:05:09,198 --> 00:05:11,062
Features X が表示される。

133
00:05:11,062 --> 00:05:14,164
そしてこれがそのデータだ。

134
00:05:14,200 --> 00:05:16,419
size(Features X) と入力してもいい。

135
00:05:16,419 --> 00:05:18,022
これは

136
00:05:18,022 --> 00:05:20,519
47 x 2 の行列だ。

137
00:05:20,519 --> 00:05:22,307
そして同様に 、

138
00:05:22,320 --> 00:05:23,729
size(Price Y) と打つと、

139
00:05:23,729 --> 00:05:26,753
47 x 1 ベクトルを返す。

140
00:05:26,753 --> 00:05:30,125
これは 47次元ベクトルだ。

141
00:05:30,125 --> 00:05:32,080
この列ベクトルに含まれるのは、

142
00:05:32,080 --> 00:05:35,231
訓練セットに含まれる、すべての価格 Y だ。

143
00:05:35,240 --> 00:05:37,584
さて、 Who 関数は

144
00:05:37,600 --> 00:05:40,086
現在ワークスペースにある変数を示す。

145
00:05:40,086 --> 00:05:42,195
また、WhoS  変数 とすると、

146
00:05:42,195 --> 00:05:45,369
詳細が表示される。

147
00:05:45,369 --> 00:05:47,252
そしてこの場合も、

148
00:05:47,270 --> 00:05:48,574
最後に S がつくと、

149
00:05:48,574 --> 00:05:49,979
変数の一覧を表示するが、

150
00:05:49,979 --> 00:05:51,782
違いは、サイズも表示する点だ。

151
00:05:51,790 --> 00:05:52,759
だから A は 3x2 の行列、

152
00:05:52,759 --> 00:05:54,764
Features X は

153
00:05:54,764 --> 00:05:56,545
47 x 2 の行列、

154
00:05:56,545 --> 00:05:59,327
Price Y は　47 x 1 の行列で、

155
00:05:59,327 --> 00:06:01,098
つまりこれは単なるベクトルだ。

156
00:06:01,130 --> 00:06:03,438
さらに、消費メモリ量や、

157
00:06:03,438 --> 00:06:06,020
データ型も表示する。

158
00:06:06,020 --> 00:06:07,765
Double は倍精度浮動小数点数、

159
00:06:07,765 --> 00:06:08,915
つまりこれは実数で、

160
00:06:08,915 --> 00:06:13,148
浮動小数点数であるということだ。

161
00:06:13,148 --> 00:06:14,190
次に、

162
00:06:14,190 --> 00:06:17,316
変数の削除には、clear コマンドを使う。

163
00:06:17,340 --> 00:06:21,124
だから clear Features X として、 whos を再実行すると

164
00:06:21,130 --> 00:06:23,448
このように Features X という

165
00:06:23,448 --> 00:06:26,465
変数は消える。

166
00:06:27,070 --> 00:06:28,167
では、データを保存する方法。

167
00:06:28,167 --> 00:06:29,221
見てみよう。

168
00:06:29,221 --> 00:06:30,411
変数 V を例に使い、

169
00:06:30,411 --> 00:06:33,075
仮にそれが Price Y (1:10)  とする。

170
00:06:33,075 --> 00:06:34,826
こうすると、 

171
00:06:34,826 --> 00:06:38,574
V には 最初の10要素が、

172
00:06:38,860 --> 00:06:43,215
ベクトル Y から 読み込まれる。

173
00:06:43,220 --> 00:06:46,612
who または whos と入力すると、 

174
00:06:46,612 --> 00:06:48,474
Y は 47 x 1 のベクトルだったのに対し、

175
00:06:48,474 --> 00:06:50,809
V が 10 x 1 だ。

176
00:06:50,809 --> 00:06:52,451
 V = Price Y (1 :10 )とすると、

177
00:06:52,451 --> 00:06:53,520
これは単に、  

178
00:06:53,520 --> 00:06:55,705
Y の最初の 10 要素だ。

179
00:06:55,705 --> 00:06:57,398
このデータをディスクに保存したい。

180
00:06:57,398 --> 00:07:00,129
コマンドは save hello.mat V。

181
00:07:00,129 --> 00:07:02,302
こうすると

182
00:07:02,310 --> 00:07:04,357
変数 V が保存されるのは

183
00:07:04,370 --> 00:07:05,690
hello.mat というファイルだ。

184
00:07:05,720 --> 00:07:08,490
ではやってみよう。

185
00:07:08,640 --> 00:07:10,965
そして、今ファイルが

186
00:07:11,030 --> 00:07:13,181
デスクトップに現れた。

187
00:07:13,181 --> 00:07:15,066
名前は、Hello.mat だ。

188
00:07:15,066 --> 00:07:16,509
たまたま MATLAB が入っていて、

189
00:07:16,530 --> 00:07:17,962
この Windowでは、

190
00:07:17,962 --> 00:07:19,711
このアイコンが

191
00:07:19,711 --> 00:07:21,621
こうなのは、 Windows が

192
00:07:21,621 --> 00:07:23,559
それを MATLAB ファイルと認識しているからで、

193
00:07:23,559 --> 00:07:24,882
もしこのファイルのアイコンが

194
00:07:24,890 --> 00:07:26,051
自分のマシンで、

195
00:07:26,051 --> 00:07:28,778
違う表示でも、心配ない。

196
00:07:28,778 --> 00:07:31,017
さて、すべての変数をクリアしたとする。

197
00:07:31,020 --> 00:07:32,602
つまり、clear だけ入力して、何も指定しなければ、

198
00:07:32,602 --> 00:07:36,061
これはワークペース内の、全変数を削除する。

199
00:07:36,080 --> 00:07:39,078
whos を実行しても、ワークスペースには何も残っていない。

200
00:07:39,078 --> 00:07:41,856
そこで hello.mat を読み込むと、

201
00:07:41,856 --> 00:07:44,388
再度 読み込まれる、

202
00:07:44,388 --> 00:07:46,054
変数 V に。

203
00:07:46,054 --> 00:07:47,830
含まれるデータは、

204
00:07:47,830 --> 00:07:51,035
先ほど、hello.mat ファイルに保存したものだ。

205
00:07:51,035 --> 00:07:54,636
では、 hello.mat つまり、今実行した save hello.mat V、

206
00:07:54,636 --> 00:07:55,877
これで保存されるのは

207
00:07:55,877 --> 00:07:57,811
バイナリ形式のデータ、

208
00:07:57,850 --> 00:07:59,702
多少圧縮された、バイナリ形式だ。

209
00:07:59,702 --> 00:08:01,077
だから 、V が大きな データの場合、

210
00:08:01,077 --> 00:08:03,899
これは多少圧縮され、

211
00:08:03,899 --> 00:08:05,645
消費するスペースが多少減る。

212
00:08:05,650 --> 00:08:06,784
もし、保存する形式として

213
00:08:06,784 --> 00:08:08,959
人間が読める

214
00:08:08,959 --> 00:08:11,870
データ形式にしたい場合は、

215
00:08:11,870 --> 00:08:14,055
save hello.txt 変数 V、そして -ascii。

216
00:08:14,110 --> 00:08:16,083
すると、これは

217
00:08:16,083 --> 00:08:18,787
テキストとして

218
00:08:18,840 --> 00:08:21,352
ASCII テキストで保存される。

219
00:08:21,352 --> 00:08:22,802
すると、これを実行したので

220
00:08:22,802 --> 00:08:24,973
このファイルができた。

221
00:08:24,973 --> 00:08:26,115
Hello.txt が今

222
00:08:26,130 --> 00:08:28,463
デスクトップに表示され、

223
00:08:28,463 --> 00:08:29,951
それを開くと、

224
00:08:29,951 --> 00:08:31,016
テキストファイルで、

225
00:08:31,016 --> 00:08:33,958
データが保存されている。

226
00:08:33,958 --> 00:08:36,698
これが、データの読み込みと保存だ。

227
00:08:36,698 --> 00:08:38,832
では、少しデータの操作について話す。

228
00:08:38,832 --> 00:08:40,526
A = をその

229
00:08:40,526 --> 00:08:44,910
A の行列として指定すると、3 x 2 の行列になる。

230
00:08:45,710 --> 00:08:46,778
位置を指定するには、

231
00:08:46,778 --> 00:08:48,493
A(3, 2) と入力する。

232
00:08:48,493 --> 00:08:51,219
こうすると

233
00:08:51,219 --> 00:08:52,917
3、2 の要素が

234
00:08:52,917 --> 00:08:54,308
行列 A から読み出される。

235
00:08:54,370 --> 00:08:56,320
これは通常、

236
00:08:56,400 --> 00:08:57,488
表記上は

237
00:08:57,510 --> 00:09:00,421
添え字で A<u>{3、2}</u>

238
00:09:00,430 --> 00:09:02,280
あるいは A 添え字

239
00:09:03,570 --> 00:09:05,320
3、2

240
00:09:05,380 --> 00:09:07,028
そして、これがその要素で、

241
00:09:07,028 --> 00:09:08,664
3 番目の行と、 2 番目の列が

242
00:09:08,664 --> 00:09:11,539
A から読み出され、その要素は 6 だ。

243
00:09:11,590 --> 00:09:13,820
また、A、2、

244
00:09:14,550 --> 00:09:16,770
カンマ、コロン、とすると、

245
00:09:16,770 --> 00:09:18,851
二番目の行の、全要素を取得できる。

246
00:09:18,851 --> 00:09:22,806
だから、コロンの意味は

247
00:09:22,810 --> 00:09:27,381
その行、あるいは列の全要素だ。

248
00:09:27,420 --> 00:09:29,274
よって A( 2, : )

249
00:09:29,274 --> 00:09:32,425
は A の二番目の行だ。

250
00:09:32,470 --> 00:09:35,662
そして同様に コロン、カンマ、2 だと、

251
00:09:35,680 --> 00:09:38,262
その意味は、全要素を

252
00:09:38,262 --> 00:09:41,328
A の二番目の列から参照する、つまり 2 4 6 が戻され、

253
00:09:41,328 --> 00:09:42,921
確かに、この意味は

254
00:09:42,930 --> 00:09:45,467
A、全要素、二列目、となる。

255
00:09:45,500 --> 00:09:46,967
だから、これが

256
00:09:46,970 --> 00:09:49,636
Aの二列目、2 4 6。

257
00:09:49,650 --> 00:09:51,267
さらに、もっと高度な

258
00:09:51,280 --> 00:09:54,148
インデックス方法を、演算で使うこともできる。

259
00:09:54,148 --> 00:09:56,575
では、ざっと例を見せよう。

260
00:09:56,575 --> 00:09:58,537
使用頻度は低いが、

261
00:09:58,550 --> 00:10:02,231
ここで A([1 3], :) を試してみる。

262
00:10:02,231 --> 00:10:03,471
この意味は、

263
00:10:03,500 --> 00:10:07,444
Aの要素で最初のインデックスが 1 または 3 のものすべて、

264
00:10:07,450 --> 00:10:08,765
つまり、この意味は、

265
00:10:08,765 --> 00:10:10,588
最初と三番目の行の

266
00:10:10,603 --> 00:10:12,780
すべての

267
00:10:13,240 --> 00:10:13,240
列の要素を参照、

268
00:10:14,163 --> 00:10:16,430
だから、

269
00:10:16,800 --> 00:10:18,260
行列 A で

270
00:10:18,440 --> 00:10:21,872
A( [1 3], : ) の意味は、

271
00:10:21,900 --> 00:10:23,222
一番目の行からすべてと

272
00:10:23,250 --> 00:10:25,023
二番目の行

273
00:10:25,023 --> 00:10:27,172
いえ、三行目からすべてを取得し、

274
00:10:27,172 --> 00:10:28,313
コロンは、

275
00:10:28,313 --> 00:10:29,585
最初と二番目両方の列、

276
00:10:29,585 --> 00:10:31,045
だから、これは

277
00:10:31,045 --> 00:10:32,842
1 2 5 6 を返す。

278
00:10:32,842 --> 00:10:34,353
このような

279
00:10:34,353 --> 00:10:37,182
高度な添え字インデックスの

280
00:10:37,182 --> 00:10:39,819
操作の使用頻度は、多少低いだろう。

281
00:10:40,210 --> 00:10:41,453
これ以外にも、できることを見せよう。

282
00:10:41,453 --> 00:10:43,617
ここに 行列 A があり、

283
00:10:43,617 --> 00:10:47,276
これは A(:, 2) で、二番目の列を返す。

284
00:10:47,276 --> 00:10:49,773
これを代入にも使える。

285
00:10:49,773 --> 00:10:51,178
そこで、二番目の列を

286
00:10:51,190 --> 00:10:52,949
A から指定して、

287
00:10:52,950 --> 00:10:55,605
そこに 10、11、12、と代入し、

288
00:10:55,670 --> 00:10:58,084
実行すると、

289
00:10:58,120 --> 00:10:59,220
これは二番目の列を A で指定し、

290
00:10:59,290 --> 00:11:02,768
そこにこの列ベクトル 10、11、12 を代入する。

291
00:11:02,768 --> 00:11:05,440
だからこの行列は、これが1、3、5 で

292
00:11:05,480 --> 00:11:08,760
二列目が 10、11、12 に置換された。

293
00:11:08,760 --> 00:11:14,513
さらに別の操作もある。

294
00:11:14,680 --> 00:11:15,917
A を = A カンマ、

295
00:11:15,917 --> 00:11:17,738
100、101、 102 と

296
00:11:17,750 --> 00:11:21,605
このように指定すると、

297
00:11:21,605 --> 00:11:24,109
この処理によって、

298
00:11:24,120 --> 00:11:28,025
別の列ベクトルが

299
00:11:28,047 --> 00:11:29,855
右に追加される。

300
00:11:29,890 --> 00:11:33,230
だから、ここで、おっと、

301
00:11:33,260 --> 00:11:36,798
少し間違いがあった。

302
00:11:36,800 --> 00:11:41,065
ここにセミコロンを入れなくては。

303
00:11:41,700 --> 00:11:43,510
すると、A はこれにイコールとなる。

304
00:11:43,510 --> 00:11:44,564
いいかな？

305
00:11:44,564 --> 00:11:45,479
この意味が分かるかな？

306
00:11:45,479 --> 00:11:46,980
だから、これが 100, 101, 102 で

307
00:11:46,980 --> 00:11:48,804
これが列ベクトル

308
00:11:48,820 --> 00:11:51,668
そこで実行したのは、

309
00:11:51,668 --> 00:11:53,386
A = とし、

310
00:11:53,386 --> 00:11:56,156
そこに A の元の定義を代入し、

311
00:11:56,156 --> 00:11:57,368
さらに、その列ベクトルを

312
00:11:57,380 --> 00:11:59,192
右に追加した。

313
00:11:59,192 --> 00:12:00,217
これにより、

314
00:12:00,217 --> 00:12:04,288
行列 A は、もともと

315
00:12:04,288 --> 00:12:05,405
左にある 6 つの要素だったが、

316
00:12:05,405 --> 00:12:06,785
その行列

317
00:12:06,810 --> 00:12:08,564
A を指定して、

318
00:12:08,564 --> 00:12:09,793
別の列ベクトルを、その右に追加した。

319
00:12:09,793 --> 00:12:11,814
このため、A は今は

320
00:12:11,814 --> 00:12:16,083
3 x 3 の行列となり、こう表示される。

321
00:12:16,200 --> 00:12:18,005
そして最後に、私が時々使う、

322
00:12:18,010 --> 00:12:19,802
小さなコツについて。

323
00:12:19,810 --> 00:12:22,022
このように単に A(:) とする。

324
00:12:22,022 --> 00:12:25,585
これは少し特別な構文だ。

325
00:12:25,590 --> 00:12:28,695
これの意味は、A の全要素を

326
00:12:28,695 --> 00:12:30,751
単一の列ベクトルに入れる、ということで、

327
00:12:30,850 --> 00:12:34,513
9 x 1 のベクトルが返される。

328
00:12:34,513 --> 00:12:38,584
これは単に、全要素を連結しただけだ。

329
00:12:39,700 --> 00:12:45,258
あと、例をひとつふたつ。

330
00:12:45,300 --> 00:12:52,073
例えば、Aを = 1、2、3、4、5、6 とする。

331
00:12:52,181 --> 00:12:54,035
さらに、

332
00:12:54,060 --> 00:12:55,674
B を

333
00:12:55,680 --> 00:12:58,984
B = 11、12、13、14、15、16。

334
00:12:58,984 --> 00:13:00,346
すると、新たな

335
00:13:00,346 --> 00:13:03,161
行列 C を、 A B から作成できる。

336
00:13:03,200 --> 00:13:05,010
これの意味は、

337
00:13:05,080 --> 00:13:06,666
単に、行列 A、ここに行列 B 、

338
00:13:06,666 --> 00:13:08,426
そして C を = [A B] と

339
00:13:08,426 --> 00:13:11,053
指定する。

340
00:13:11,070 --> 00:13:12,225
何をしているかというと、

341
00:13:12,225 --> 00:13:15,438
二つの行列を連結しただけだ。

342
00:13:15,438 --> 00:13:18,408
左側には、行列 A が左に

343
00:13:18,420 --> 00:13:20,786
そして、行列 B が右にある。

344
00:13:20,800 --> 00:13:23,738
このようにして

345
00:13:23,830 --> 00:13:27,145
二つを連結して、行列 C を作成した。

346
00:13:27,145 --> 00:13:28,927
また、 

347
00:13:28,927 --> 00:13:31,975
C = [A; B]。

348
00:13:32,000 --> 00:13:35,552
セミコロン表記の意味は、

349
00:13:35,552 --> 00:13:38,881
次の行列を下につける。

350
00:13:38,881 --> 00:13:39,880
ここで C=[A; B] を

351
00:13:39,910 --> 00:13:41,169
実行する。

352
00:13:41,170 --> 00:13:42,408
これも、行列 A と B を

353
00:13:42,460 --> 00:13:44,048
連結するが、この場合は

354
00:13:44,048 --> 00:13:46,408
上下に連結される。

355
00:13:46,408 --> 00:13:49,675
だから、A が上に、そして B が下に、

356
00:13:49,675 --> 00:13:52,038
そして C は 6 x 2 の行列になる。

357
00:13:52,038 --> 00:13:54,263
このように、セミコロンは

358
00:13:54,270 --> 00:13:56,705
通常、次の行という意味なので

359
00:13:56,705 --> 00:13:58,463
C は、A と

360
00:13:58,463 --> 00:13:59,598
その下に

361
00:13:59,598 --> 00:14:00,610
B が配置される。

362
00:14:00,690 --> 00:14:02,320
ところで、

363
00:14:02,390 --> 00:14:04,225
この [A B] は

364
00:14:04,225 --> 00:14:05,734
[A, B] と同じ意味なので、

365
00:14:05,750 --> 00:14:09,106
どれも同じ結果になる。

366
00:14:10,310 --> 00:14:11,916
さて、ここまでで、

367
00:14:11,916 --> 00:14:14,256
恐らく、Octaveについてわかっただろう、

368
00:14:14,260 --> 00:14:17,207
行列を作成する方法や、

369
00:14:17,207 --> 00:14:18,223
また、いくつか、

370
00:14:18,223 --> 00:14:19,822
便利なコマンドも紹介したので、

371
00:14:19,850 --> 00:14:21,913
手早く行列を作成して、

372
00:14:21,940 --> 00:14:23,390
そうした行列を利用して、

373
00:14:23,390 --> 00:14:24,984
組み合わせることで、

374
00:14:25,000 --> 00:14:27,009
より大きな行列を作成することが、

375
00:14:27,009 --> 00:14:28,962
ほんの数行のコードでできるので、

376
00:14:28,962 --> 00:14:30,770
Octave が非常に便利で、

377
00:14:30,770 --> 00:14:32,683
いかに手早く、複雑な行列を作成して、

378
00:14:32,683 --> 00:14:36,033
データを操作できるか、わかっただろう。

379
00:14:36,050 --> 00:14:38,027
データの操作方法は、以上だ。

380
00:14:38,027 --> 00:14:39,347
次のビデオでは、

381
00:14:39,347 --> 00:14:40,783
実際にどのようにして、

382
00:14:40,860 --> 00:14:46,232
複雑な演算処理をするかを説明する。

383
00:14:46,830 --> 00:14:48,256
だから、これで

384
00:14:48,256 --> 00:14:49,961
感覚的に理解してもらえたと思う。

385
00:14:49,961 --> 00:14:51,049
いつくかのコマンドだけで、

386
00:14:51,049 --> 00:14:54,573
Octave で、簡単なデータを取り扱うこと、

387
00:14:54,590 --> 00:14:56,164
ベクトルや行列の読み込みと保存、

388
00:14:56,180 --> 00:14:58,059
データの読み込みと保存、

389
00:14:58,090 --> 00:15:00,201
行列の組み合わせによる、

390
00:15:00,201 --> 00:15:02,990
新規の行列の作成、行列内の特定の、

391
00:15:02,990 --> 00:15:05,021
要素の参照方法、など。

392
00:15:05,021 --> 00:15:06,015
かなり色々なコマンドを

393
00:15:06,015 --> 00:15:06,944
紹介したので、

394
00:15:06,980 --> 00:15:08,244
一番いいのは、

395
00:15:08,244 --> 00:15:09,741
この後で、

396
00:15:09,741 --> 00:15:12,248
私の入力内容の講義録を見て

397
00:15:12,248 --> 00:15:13,286
つまり、それを見るには、

398
00:15:13,286 --> 00:15:14,661
コースワークのウェブサイトを見て、

399
00:15:14,661 --> 00:15:15,927
このセッションの講義録を

400
00:15:15,950 --> 00:15:17,479
そこからダウンロードして、

401
00:15:17,479 --> 00:15:18,820
講義録を見ながら、

402
00:15:18,820 --> 00:15:21,942
こうしたコマンドを Octave に自分で打ち込み、

403
00:15:21,942 --> 00:15:24,752
うまく動くよう、色々と試すことだ。

404
00:15:24,752 --> 00:15:28,113
もちろん、コマンドの暗記は不要で、

405
00:15:28,113 --> 00:15:30,030
その代わりに、

406
00:15:30,030 --> 00:15:31,852
すべきことは、

407
00:15:31,852 --> 00:15:32,910
このビデオを通して、

408
00:15:32,910 --> 00:15:35,065
できることの概要を把握し、

409
00:15:35,100 --> 00:15:36,519
後で、実際に

410
00:15:36,520 --> 00:15:37,902
プログラミングで、

411
00:15:37,902 --> 00:15:39,630
学習アルゴリズムを実装している時に、

412
00:15:39,630 --> 00:15:40,921
何か特定の

413
00:15:40,930 --> 00:15:42,455
コマンドを探す際に、

414
00:15:42,455 --> 00:15:43,878
Octave で可能なことを思い出すと、

415
00:15:43,878 --> 00:15:45,325
ここで見たことが、役に立つかもしれない。

416
00:15:45,325 --> 00:15:47,300
その時に、講義録で

417
00:15:47,300 --> 00:15:48,545
このセッションを見返すと

418
00:15:48,560 --> 00:15:51,693
使いたいコマンドが見つかるだろう。

419
00:15:51,693 --> 00:15:53,069
ということで、

420
00:15:53,069 --> 00:15:54,841
以上でデータの操作については終了し、

421
00:15:54,841 --> 00:15:56,060
次のビデオで

422
00:15:56,120 --> 00:15:57,699
紹介するのは、

423
00:15:57,740 --> 00:15:59,257
実際にどのように

424
00:15:59,257 --> 00:16:01,404
複雑な演算処理を

425
00:16:01,410 --> 00:16:03,548
データを使って行うか、

426
00:16:03,550 --> 00:16:04,866
データをどのように処理するか、

427
00:16:04,866 --> 00:16:06,560
実際の学習アルゴリズムの実装について、の内容だ。
