1
00:00:00,960 --> 00:00:05,684
このビデオでは、もっと深く掘り下げて、
目的関数が何をしているかさらに直感的理解を深める。

2
00:00:05,684 --> 00:00:10,523
このビデオは、皆さんが等高線図を知っていることを前提にしている。

3
00:00:10,523 --> 00:00:15,189
もし等高線図に馴染みがなければ、このビデオで見る図の中には

4
00:00:15,189 --> 00:00:20,144
意味がわからないものがあるかもしれない。しかし大丈夫。このビデオを飛ばしても、

5
00:00:20,144 --> 00:00:24,522
等高線図を見たことがなくて意味がよくわからない部分があっても、大丈夫だ。

6
00:00:24,522 --> 00:00:29,246
こうした部分が抜けても、このコースの他の内容の理解には支障ない。

7
00:00:29,246 --> 00:00:34,935
ここに、いつも通りの問題の定式がある。

8
00:00:34,935 --> 00:00:39,882
仮説、パラメータ、目的関数、そして最適化の目的だ。

9
00:00:39,882 --> 00:00:45,163
前のビデオとは異なり、今回は両方のパラメータを使い、

10
00:00:45,163 --> 00:00:50,573
theta 0 と theta 1 を使って目的関数の可視化を行う。

11
00:00:50,573 --> 00:00:57,204
さて、前と同じように、仮説 h と 目的関数 J を理解したいと思う。

12
00:00:57,204 --> 00:01:04,167
だから、ここに住宅価格の訓練セットがあり、適当に仮説を設定しよう。
そうだな、こんな感じに。

13
00:01:04,167 --> 00:01:10,219
これは特に良い仮説ではないが、theta 0 = 50 ,

14
00:01:10,219 --> 00:01:16,270
theta 1 = 0.06 と設定すると、この下の仮説になり、

15
00:01:16,270 --> 00:01:22,190
それがこの直線に対応する。さて、こうしたtheta 0 と theta 1 の値に対して、

16
00:01:22,190 --> 00:01:27,511
それに対応する目的関数を右にプロットしたいと思う。

17
00:01:27,511 --> 00:01:33,150
前回の場合は、theta 1 のみだったので、theta 1 の関数として、

18
00:01:33,150 --> 00:01:37,814
このようなプロットを作成した。
しかし、今回はパラメータが theta 0 と theta 1 の2つだ。

19
00:01:37,814 --> 00:01:42,340
だから、プロットは少し複雑になる。

20
00:01:42,340 --> 00:01:47,699
実はパラメータが一つだけなら、プロットはこのように弓なりの形の関数になる。

21
00:01:47,699 --> 00:01:52,925
今回のようにパラメータが二つある場合も、実は、目的関数は

22
00:01:52,925 --> 00:01:58,218
弓なりの形に似たものになる。そして実際に、訓練セット次第では、

23
00:01:58,218 --> 00:02:03,511
目的関数はこのようなものになるかもしれない。さて、これは三次元表面プロットだ。

24
00:02:03,511 --> 00:02:09,404
その軸は theta 0 と theta 1 とラベル付けされている。

25
00:02:09,404 --> 00:02:15,326
だから、二つのパラメータ theta 0 と theta 1 を変えるに従い、

26
00:02:15,326 --> 00:02:20,964
目的関数 J(theta 0, theta 1) の値も変わる。 そしてこの表面の高さが

27
00:02:20,964 --> 00:02:26,347
theta 0 と theta 1 の特定の点の上に来ている。これが、縦軸だ。

28
00:02:26,347 --> 00:02:31,200
ある点の表面の高さは、J(theta 0, theta 1) の値を示している。

29
00:02:31,200 --> 00:02:36,471
そして、見てわかる通り、これはボウルの形状をしている。

30
00:02:36,471 --> 00:02:46,351
このプロットを三次元的に見てみよう。
これは、同じプロットを三次元にしたものだ。横軸はtheta 0 と theta 1 、

31
00:02:46,351 --> 00:02:52,122
縦軸は J(theta 0, theta 1) 、そしてこのプロットを回転させると、

32
00:02:52,122 --> 00:02:57,608
感覚的に表面がボウルの形をしているのが分かるだろう。

33
00:02:57,608 --> 00:03:03,592
これが目的関数 J の形だ。さて、図解を目的として、今後このビデオでは

34
00:03:03,592 --> 00:03:09,077
このような三次元表面を使って目的関数 J を見せることはない。

35
00:03:09,077 --> 00:03:16,475
代わりに、等高線図を使って

36
00:03:16,475 --> 00:03:24,748
このような表面を見せる。

37
00:03:24,748 --> 00:03:31,135
さて、ここに等高線図の例が右にある。横軸と縦軸は theta 0 と theta 1 だ。

38
00:03:31,135 --> 00:03:37,602
そして、これらの長円形、これらの楕円形がぞれぞれ示しているのは

39
00:03:37,602 --> 00:03:43,757
J(theta 0, theta 1) の値が同じになる点の一組だ。

40
00:03:43,757 --> 00:03:50,514
だから、具体的に、例えば、その点と、その点と、その点を選ぶ。

41
00:03:50,514 --> 00:03:55,583
今、マゼンタ色で書いたこの三つの点は、すべて同じ値だ。

42
00:03:55,583 --> 00:03:59,730
J (theta 0, theta 1) の値が。これらは、軸は theta 0 と theta 1 だが、

43
00:03:59,730 --> 00:04:04,774
これら三つの値が同じなのは、J(theta 0, theta 1) に対してだ。

44
00:04:04,774 --> 00:04:10,218
そしてもし以前にあまり等高線図を見たことがなければ、想像してほしい。

45
00:04:10,218 --> 00:04:14,992
ボウルの形をした関数が画面から飛び出していると。

46
00:04:14,992 --> 00:04:19,668
最小値、つまり、ボウルの底は、この点だ。分かるだろうか。

47
00:04:19,668 --> 00:04:24,285
この真ん中、同中心の楕円の真ん中だ。
そしてボウルの形をしたものが、このように画面から飛び出していると考えて欲しい。

48
00:04:24,285 --> 00:04:28,786
そして、これらの楕円はそれぞれ同じ高さで

49
00:04:28,786 --> 00:04:33,345
画面から飛び出している。そしてボウルの最小値がちょうどそこにある。

50
00:04:33,345 --> 00:04:37,787
だから、等高線図は、目的関数 J を可視化する一つの方法、

51
00:04:37,787 --> 00:04:45,185
たぶんもっと便利な方法だ。では、いくつか例を見てみよう。

52
00:04:45,185 --> 00:04:53,275
こちらに、ある特定の点がある。そしてこれは、だいたい、theta 0 = 800、

53
00:04:53,275 --> 00:05:01,964
そして多分 theta 1 = -0.15 ぐらいだろう。

54
00:05:01,964 --> 00:05:07,322
そしてこの点、この赤い点は、
theta 0、theta 1 のある特定の値の組み合わせに対応する。

55
00:05:07,322 --> 00:05:12,092
そして実際に、それはこの仮説に対応している。

56
00:05:12,092 --> 00:05:17,189
theta 0 はほぼ 800、つまり縦軸と 800 あたりで交差し、

57
00:05:17,189 --> 00:05:21,763
そして傾きはほぼ -0.15 だ。さて、この線は、データに対してあまりよく

58
00:05:21,763 --> 00:05:26,859
適合していない。この仮説 h(x) とこの値の theta 0 と theta 1, 

59
00:05:26,859 --> 00:05:32,283
これは実にあまりデータによくフィットしているとは言えない。

60
00:05:32,283 --> 00:05:37,531
だから、その評価値、そこにある値は、最小値からはほど遠いということが分かる。

61
00:05:37,531 --> 00:05:42,901
これは、かなり遠く、かなり高い評価値だ。
これはあまりにもデータによくフィットしていないからだ。

62
00:05:42,901 --> 00:05:47,247
さらにいくつか例を見てみよう。さて、ここに別の仮説がある。

63
00:05:47,247 --> 00:05:52,489
これも、それほどデータにフィットしていないが、多少はましなようだ。

64
00:05:52,489 --> 00:05:57,986
だから、これがその点、パラメータ theta 0 と theta 1 の値だ。

65
00:05:57,986 --> 00:06:07,387
だから、theta 0 の値は、これは約 360 だ。

66
00:06:07,387 --> 00:06:14,047
そしてtheta 1 の値は = 0 だ。ではこれを書き出そう。

67
00:06:14,047 --> 00:06:20,063
theta 0 = 360、theta 1 = 0。そしてこの一組のパラメータは

68
00:06:20,063 --> 00:06:26,161
この仮説に対応し、それはこの横線に対応する。これは h(x) =  360 + 0x だ。

69
00:06:26,161 --> 00:06:32,421
だからこれが仮説だ。そしてこの仮説にも評価値があり、

70
00:06:32,421 --> 00:06:38,600
そしてその評価値は、その点での J 関数の高さとしてプロットされている。

71
00:06:38,791 --> 00:06:44,886
さらに二つほど例を見てみよう。ここにもう一つある。

72
00:06:44,886 --> 00:06:52,231
この値の theta 0 と この値の theta 1 は、この仮説 h(x) に対応する。

73
00:06:52,231 --> 00:06:58,599
そしてまた、データに対しあまりよいフィットではない。
事実、最小値から遠ざかっている。

74
00:06:58,599 --> 00:07:03,450
最後の例として、これは完全には最小値ではないが、かなり最小値に近い。
だから、これはそれほど

75
00:07:03,450 --> 00:07:08,486
データへのフィットは悪くない。ある特定の値の theta 0 に対し

76
00:07:08,486 --> 00:07:13,337
その値がなんであれ、そして特定の値の theta 1 では、

77
00:07:13,337 --> 00:07:18,004
特定の h(x) が得られる。これは最小値ではないが、かなり近い。

78
00:07:18,004 --> 00:07:23,039
二乗誤差の総和は、訓練サンプルと仮説の間の距離の二乗の総和だ。

79
00:07:23,039 --> 00:07:28,259
実際、これは距離の二乗の総和だ。こうしたすべての誤差の。

80
00:07:28,259 --> 00:07:32,548
これは完全に最小値ではないにしても、かなり最小値に近くなっている、

81
00:07:32,548 --> 00:07:37,096
さて、こうした図解を通して、

82
00:07:37,096 --> 00:07:41,869
目的関数 J の値の値が何か、どのような形をしていて、

83
00:07:41,869 --> 00:07:47,324
どのように異なる仮説に対応するか、
そしていかに仮説がよいほど、対応する点が目的関数 J の最小値により近くなるか、

84
00:07:47,324 --> 00:07:52,983
分かってもらえたと思う。さて、もちろん、

85
00:07:52,983 --> 00:07:57,619
本当に欲しいのは、効率的なアルゴリズム、効率的なソフトウェアを使って、

86
00:07:57,619 --> 00:08:02,218
自動的に目的関数 J を最小化する theta 0 と theta 1 の値を見つけることだ。

87
00:08:02,218 --> 00:08:06,566
私たちは、こうした点をプロットして目視で数値を読み取っていくような、

88
00:08:06,566 --> 00:08:10,697
そんなソフトウェアを書くことは避けたい。

89
00:08:10,697 --> 00:08:15,263
それは、あまり良いやり方ではない。そして、事実、後ほど見る通り、

90
00:08:15,426 --> 00:08:19,938
もっと複雑な例を見る場合、高次元の図でより多くのパラメータを扱うことになり、

91
00:08:19,938 --> 00:08:23,906
結果的に、後で実例をいくつかこのコースで見ていくが、

92
00:08:23,906 --> 00:08:28,091
こうした図をプロットすることはできず、

93
00:08:28,091 --> 00:08:33,664
可視化がより困難になっていく。だから、私たちが欲しいのは

94
00:08:33,664 --> 00:08:37,729
この関数を最小化するような theta 0 と theta 1 の値を見つけてくれるソフトウェアだ。

95
00:08:37,916 --> 00:08:42,914
そして、次のビデオで、自動的に目的関数 J を最小化するような

96
00:08:42,914 --> 00:08:47,600
theta 0 と theta 1 の値を見つけるアルゴリズムについて話していく。
